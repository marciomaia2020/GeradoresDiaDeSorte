<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Palpites Baseado em dígitos- Dia de Sorte</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                    }
                }
            },
            darkMode: 'class',
        }
    </script>
    <style>
        @media print {
            .no-print {
                display: none;
            }
            .page-break {
                page-break-after: always;
            }
        }
        
        footer {
                color: #161515;
                text-align: center;
                padding: 5px;
                margin-bottom: auto;
                margin-top: 10px; /* Espaço acima do rodapé */
        }
        .small{
                font-size: 16px;
                font-style: italic;
        }
        
        .toggle-btn {
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        
        .toggle-btn.active {
            transform: rotate(180deg);
        }
        
        .transition-height {
            transition: max-height 0.5s ease-out;
            overflow: hidden;
        }
        
        .number-low {
            background-color: rgba(134, 239, 172, 0.9);
            color: rgb(22, 101, 52);
        }
        
        .dark .number-low {
            background-color: rgba(22, 101, 52, 0.7);
            color: rgb(187, 247, 208);
        }
        
        .number-medium {
            background-color: rgba(253, 230, 138, 0.9);
            color: rgb(146, 64, 14);
        }
        
        .dark .number-medium {
            background-color: rgba(146, 64, 14, 0.7);
            color: rgb(254, 240, 138);
        }
        
        .number-high {
            background-color: rgba(252, 165, 165, 0.9);
            color: rgb(153, 27, 27);
        }
        
        .dark .number-high {
            background-color: rgba(153, 27, 27, 0.7);
            color: rgb(254, 202, 202);
        }
        
        /* Estilos para exibição da frequência das dezenas */
        .frequency-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }
        
        .frequency-ball {
            position: relative;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            background-color: #f3f4f6;
            border: 2px solid transparent;
            color: #1f2937;
            margin: 0 auto;
        }
        
        .dark .frequency-ball {
            background-color: #374151;
            color: #f3f4f6;
        }
        
        .freq-low {
            border-color: #10b981;
        }
        
        .freq-medium {
            border-color: #f59e0b;
        }
        
        .freq-high {
            border-color: #ef4444;
        }
        
        /* Nova animação de pulsação para o número mais frequente */
        @keyframes maxFreqPulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            50% { transform: scale(1.1); box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        
        .freq-max {
            animation: maxFreqPulse 1.5s infinite;
            z-index: 5;
            border-width: 3px !important;
            border-color: #ef4444 !important;
        }
        
        .dark .freq-max {
            border-color: #f87171 !important;
        }
        
        .freq-value {
            position: absolute;
            top: -8px;
            right: -8px;
            background-color: #4b5563;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 0.7rem;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Estilos para o mês da sorte */
        .month-ball {
            padding: 2px 6px;
            border-radius: 12px;
            background-color: #8b5cf6;
            color: white;
            font-weight: bold;
            font-size: 0.8rem;
        }
        
        .dark .month-ball {
            background-color: #7c3aed;
        }
        
        /* Destacar mês mais frequente */
        .month-highlight {
            box-shadow: 0 0 0 3px #fbbf24, 0 0 10px #fbbf24;
            animation: pulse 1.5s infinite;
        }
        
        /* Estilos para os padrões de dígitos */
        .pattern-bar {
            height: 20px;
            background-color: #0d9488;
            border-radius: 4px;
            transition: width 1s ease-out;
        }
        
        .dark .pattern-bar {
            background-color: #14b8a6;
        }
        
        .pattern-example {
            background-color: rgba(13, 148, 136, 0.2);
            transition: background-color 0.3s;
        }
        
        .pattern-example:hover {
            background-color: rgba(13, 148, 136, 0.4);
        }
        
        .dark .pattern-example {
            background-color: rgba(20, 184, 166, 0.2);
        }
        
        .dark .pattern-example:hover {
            background-color: rgba(20, 184, 166, 0.4);
        }
        
        /* Estilo para botão de mostrar mais padrões */
        .show-more-btn {
            cursor: pointer;
            padding: 5px 10px;
            background-color: #0d9488;
            color: white;
            border-radius: 4px;
            font-size: 0.9rem;
            margin-top: 8px;
            display: inline-block;
            transition: background-color 0.3s;
        }
        
        .show-more-btn:hover {
            background-color: #0f766e;
        }
        
        .dark .show-more-btn {
            background-color: #14b8a6;
        }
        
        .dark .show-more-btn:hover {
            background-color: #0d9488;
        }
        
        /* Estilo para padrões escondidos */
        .hidden-patterns {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-out;
        }
        
        .hidden-patterns.visible {
            max-height: 1000px;
        }
        
        /* Estilos para a seleção de padrões */
        .pattern-selector {
            padding: 10px;
            background-color: rgba(13, 148, 136, 0.1);
            border-radius: 8px;
            margin-top: 16px;
        }
        
        .pattern-checkbox {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 6px;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        
        .pattern-checkbox:hover {
            background-color: rgba(13, 148, 136, 0.2);
        }
        
        .pattern-checkbox input[type="checkbox"] {
            margin-right: 8px;
            width: 18px;
            height: 18px;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.7); }
            70% { box-shadow: 0 0 0 5px rgba(251, 191, 36, 0); }
            100% { box-shadow: 0 0 0 2px rgba(251, 191, 36, 0); }
        }
        
        /* Estilos para o modal popup */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow-y: auto;
        }
        
        .modal-content {
            background-color: white;
            margin: 2rem auto;
            max-width: 90%;
            width: 800px;
            border-radius: 8px;
            position: relative;
        }
        
        .dark .modal-content {
            background-color: #1f2937;
            color: #e5e7eb;
        }
        
        .modal-header {
            padding: 1rem;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .dark .modal-header {
            border-bottom: 1px solid #4b5563;
        }
        
        .modal-body {
            padding: 1.5rem;
            max-height: 70vh;
            overflow-y: auto;
        }
        
        .modal-footer {
            padding: 1rem;
            border-top: 1px solid #e2e8f0;
            text-align: right;
        }
        
        .dark .modal-footer {
            border-top: 1px solid #4b5563;
        }
        
        .close-btn {
            cursor: pointer;
            font-size: 1.5rem;
            font-weight: bold;
        }
        
        /* Animação para as barras de estatística */
        @keyframes barGrow {
            from { height: 0%; }
            to { height: var(--target-height); }
        }
        
        .stat-bar-group .stat-bar {
            animation: barGrow 1s ease-out forwards;
        }
        
        /* Spinner para carregamento */
        @keyframes spinner {
            to {transform: rotate(360deg);}
        }
        
        .spinner {
            display: inline-block;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            animation: spinner 0.8s linear infinite;
        }
				/* Estilos para o misturador de palpites */
		.mixer-section {
			background-color: #f0f9ff;
			border-radius: 8px;
			padding: 12px;
			margin-bottom: 16px;
		}

		.dark .mixer-section {
			background-color: #0c4a6e;
		}

		.mixer-card {
			border: 1px solid #cbd5e1;
			border-radius: 8px;
			padding: 12px;
			margin-bottom: 8px;
			background-color: white;
			transition: all 0.2s ease;
		}

		.mixer-card:hover {
			border-color: #5D5CDE;
			box-shadow: 0 2px 8px rgba(93, 92, 222, 0.2);
		}

		.dark .mixer-card {
			background-color: #1e293b;
			border-color: #334155;
		}

		.dark .mixer-card:hover {
			border-color: #818cf8;
			box-shadow: 0 2px 8px rgba(129, 140, 248, 0.2);
		}
		
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-800 dark:text-gray-200 min-h-screen">
    <!-- Dark mode detection -->
    <script>
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });
    </script>

    <!-- Modal de Instruções -->
    <div id="instructionsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="text-2xl font-bold text-primary">Como Usar o Gerador de Palpites</h2>
                <span class="close-btn" id="closeModal">&times;</span>
            </div>
            <div class="modal-body">
                <div class="space-y-6">
                    <section>
                        <h3 class="text-xl font-semibold text-primary mb-2">Introdução</h3>
                        <p class="mb-2">Este aplicativo utiliza uma abordagem matemática para gerar palpites para a loteria Dia de Sorte, baseando-se em combinações de dígitos que ainda não foram sorteadas.</p>
                        <p>A estratégia principal é identificar quais combinações de 5 dígitos (de 0 a 9) nunca apareceram nos sorteios anteriores, maximizando suas chances ao jogar exclusivamente com estas combinações inexploradas.</p>
                    </section>
                    
                    <section>
                        <h3 class="text-xl font-semibold text-primary mb-2">Passo a Passo</h3>
                        
                        <div class="mb-4">
                            <h4 class="font-bold">1. Analisar Resultados Anteriores</h4>
                            <ul class="list-disc pl-6 mt-1 mb-2">
                                <li>Expanda a seção "Análise de Frequência de Resultados Anteriores"</li>
                                <li>Clique em "Buscar Resultados" para importar os sorteios passados automaticamente, ou</li>
                                <li>Cole manualmente os resultados na caixa de texto (cada linha deve conter os números de um sorteio)</li>
                                <li>Clique em "Analisar Frequência" para processar os dados</li>
                            </ul>
                            <p class="text-sm italic">O sistema identificará quais combinações de 5 dígitos nunca foram sorteadas. Estas serão automaticamente usadas para gerar seus palpites.</p>
                        </div>
                        
                        <div class="mb-4">
                            <h4 class="font-bold">2. Configurar Parâmetros (opcional)</h4>
                            <ul class="list-disc pl-6 mt-1 mb-2">
                                <li>Expanda a seção "Configurações"</li>
                                <li>Ajuste a quantidade de dezenas por palpite (7 a 15)</li>
                                <li>Configure a distribuição desejada de números baixos, médios e altos</li>
                            </ul>
                            <p class="text-sm italic">Recomendamos manter a configuração padrão para uma distribuição equilibrada.</p>
                        </div>
                        
                        <div class="mb-4">
                            <h4 class="font-bold">3. Gerar Palpites</h4>
                            <ul class="list-disc pl-6 mt-1 mb-2">
                                <li>Clique no botão "Gerar Palpites" na seção de Configurações</li>
                                <li>Os palpites serão gerados utilizando apenas as combinações que nunca foram sorteadas</li>
                                <li>Você pode filtrar os resultados por categoria (baixas, médias, altas) usando as abas</li>
                            </ul>
                        </div>
                        
                        <div class="mb-4">
                            <h4 class="font-bold">4. Explorar Combinações Específicas (opcional)</h4>
                            <ul class="list-disc pl-6 mt-1 mb-2">
                                <li>Expanda a seção "Gerador por Combinação Específica"</li>
                                <li>Selecione uma combinação de dígitos específica (as não sorteadas terão um ★)</li>
                                <li>Clique em "Gerar Palpites" para ver todas as combinações possíveis para aquele conjunto de dígitos</li>
                            </ul>
                        </div>
                        
                        <div class="mb-4">
                            <h4 class="font-bold">5. Explorar Padrões de Dígitos</h4>
                            <ul class="list-disc pl-6 mt-1 mb-2">
                                <li>Na seção "Análise de Frequência", observe os padrões de dígitos iniciais e finais</li>
                                <li>Veja quais padrões são mais frequentes nos sorteios anteriores</li>
                                <li>Use o botão "Gerar Palpites baseados nos Padrões" para criar jogos que seguem esses padrões</li>
                                <li>Selecione padrões específicos e quantidade de palpites desejada</li>
                            </ul>
                        </div>
                        
                        <div class="mb-4">
                            <h4 class="font-bold">6. Exportar seus Palpites</h4>
                            <ul class="list-disc pl-6 mt-1 mb-2">
                                <li>Use o botão "Somente Dezenas" para baixar apenas os números</li>
                                <li>Use o botão "Baixar Detalhado" para um relatório completo com estatísticas</li>
                                <li>Para imprimir, use o botão "Imprimir" na seção de Configurações</li>
                            </ul>
                        </div>
                    </section>
                    
                    <section>
                        <h3 class="text-xl font-semibold text-primary mb-2">Seções da Aplicação</h3>
                        
                        <div class="mb-3">
                            <h4 class="font-bold">Combinações de Dígitos</h4>
                            <p>Mostra as combinações de 5 dígitos que serão usadas para gerar os palpites. Após a análise, mostrará apenas as combinações que nunca foram sorteadas.</p>
                        </div>
                        
                        <div class="mb-3">
                            <h4 class="font-bold">Análise de Frequência</h4>
                            <p>Permite inserir e analisar resultados anteriores, identificando quais combinações de dígitos já apareceram e quais ainda não foram sorteadas.</p>
                        </div>
                        
                        <div class="mb-3">
                            <h4 class="font-bold">Padrões de Dígitos</h4>
                            <p>Analisa os dígitos iniciais e finais dos números sorteados, mostrando os padrões mais frequentes e permitindo gerar palpites baseados neles.</p>
                        </div>
                        
                        <div class="mb-3">
                            <h4 class="font-bold">Tabela de Combinações</h4>
                            <p>Mostra em detalhes todas as combinações disponíveis e quais números cada uma pode gerar.</p>
                        </div>
                        
                        <div class="mb-3">
                            <h4 class="font-bold">Resumo Estatístico</h4>
                            <p>Fornece estatísticas sobre as combinações e quantos números cada uma gera.</p>
                        </div>
                        
                        <div class="mb-3">
                            <h4 class="font-bold">Gerador por Combinação Específica</h4>
                            <p>Permite gerar todos os palpites possíveis para uma combinação específica de dígitos.</p>
                        </div>
                        
                        <div class="mb-3">
                            <h4 class="font-bold">Palpites Gerados</h4>
                            <p>Exibe todos os palpites gerados a partir das combinações selecionadas.</p>
                        </div>
                    </section>
                    
                    <section class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg">
                        <h3 class="text-xl font-semibold text-blue-700 dark:text-blue-300 mb-2">Resumo</h3>
                        <ol class="list-decimal pl-6 space-y-2 text-blue-800 dark:text-blue-200">
                            <li>Busque ou insira resultados anteriores da Dia de Sorte</li>
                            <li>Clique em "Analisar Frequência" para identificar combinações não sorteadas</li>
                            <li>Observe os padrões de dígitos mais frequentes nos sorteios anteriores</li>
                            <li>Ajuste as configurações conforme desejado (quantidade de dezenas, distribuição)</li>
                            <li>Clique em "Gerar Palpites" para criar jogos baseados apenas nas combinações nunca sorteadas</li>
                            <li>Exporte seus palpites usando os botões de download ou impressão</li>
                        </ol>
                        <p class="mt-4 font-bold text-blue-700 dark:text-blue-300">Jogando apenas com combinações que nunca apareceram, você estará apostando em padrões matemáticos ainda não explorados nos sorteios!</p>
                    </section>
                </div>
            </div>
            <div class="modal-footer">
                <button id="closeModalBtn" class="bg-primary hover:bg-primary/90 text-white py-2 px-6 rounded">Entendi</button>
            </div>
        </div>
    </div>

    <div class="container mx-auto px-4 py-8">
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-3xl font-bold text-center text-primary">Gerador de Palpites Baseado em Digitos - Dia de Sorte </span></h1> 
            
            <ul>
                <li><a href="Selecao-De-Digitos.html">Digitos</a></li>
                <li><a href="Combinacoes.html">Combinacoes</a></li>
            </ul>

            <button id="showInstructionsBtn" class="bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 py-2 px-4 rounded flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd" />
                </svg>
                Como Usar
            </button>
        </div>
        
        <!-- Seção: Combinações de Dígitos -->
        <div class="mb-6">
            <div class="flex items-center justify-between cursor-pointer mb-2" id="digitCombinationsHeader">
                <h2 class="text-xl font-semibold flex items-center">
                    <span>Combinações de Dígitos</span> 
                    <span class="text-sm font-bold ml-2 bg-blue-100 dark:bg-blue-800 text-blue-800 dark:text-blue-200 px-2 py-0.5 rounded-full">(126)</span>
                </h2>
                <svg class="h-6 w-6 text-gray-500 dark:text-gray-400 toggle-btn" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
            <div id="digitCombinationsContainer" class="transition-height bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded p-4" style="max-height: 0px; overflow: hidden;">
                <textarea id="digitCombinations" rows="6" class="w-full p-2 border rounded dark:bg-gray-800 dark:border-gray-700 text-base" readonly></textarea>
            </div>
        </div>
        
        <!-- Seção: Configurações -->
        <div class="mb-6">
            <div class="flex items-center justify-between cursor-pointer mb-2" id="configHeader">
                <h2 class="text-xl font-semibold">Configurações</h2>
                <svg class="h-6 w-6 text-gray-500 dark:text-gray-400 toggle-btn" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
            <div id="configContainer" class="transition-height bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded" style="max-height: 500px; overflow: hidden;">
                <div class="space-y-4 bg-gray-100 dark:bg-gray-800 p-4 rounded">
                    <div>
                        <label class="block mb-1">Quantidade de dezenas por palpite:</label>
                        <input type="number" id="numberPerBet" value="7" min="7" max="15" class="p-2 border rounded w-full dark:bg-gray-700 dark:border-gray-600 text-base">
                    </div>
                    <!-- Campo de número máximo removido, agora é fixo em 31 e oculto -->
                    <input type="hidden" id="maxNumber" value="31">
                    <div>
                        <label class="block mb-1">Distribuição por faixa:</label>
                        <div class="flex flex-wrap gap-2">
                            <div class="flex items-center gap-1">
                                <label for="lowRange" class="whitespace-nowrap">Baixas (1-10):</label>
                                <input type="number" id="lowRange" value="3" min="0" max="15" class="p-2 border rounded w-14 dark:bg-gray-700 dark:border-gray-600 text-base">
                            </div>
                            <div class="flex items-center gap-1">
                                <label for="mediumRange" class="whitespace-nowrap">Médias (11-20):</label>
                                <input type="number" id="mediumRange" value="3" min="0" max="15" class="p-2 border rounded w-14 dark:bg-gray-700 dark:border-gray-600 text-base">
                            </div>
                            <div class="flex items-center gap-1">
                                <label for="highRange" class="whitespace-nowrap">Altas (21-31):</label>
                                <input type="number" id="highRange" value="1" min="0" max="15" class="p-2 border rounded w-14 dark:bg-gray-700 dark:border-gray-600 text-base">
                            </div>
                        </div>
                        <div id="distributionSummary" class="text-sm mt-1 mb-2 text-gray-600 dark:text-gray-400"></div>
                    </div>
                    <div class="flex gap-2 mt-4">
                        <button id="generateBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-6 rounded">
                            Gerar Palpites
                        </button>
                        <button id="printBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-6 rounded">
                            Imprimir
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Seção: Análise de Frequência -->
        <div class="mb-6">
            <div class="flex items-center justify-between cursor-pointer mb-2" id="frequencyHeader">
                <h2 class="text-xl font-semibold">Análise de Frequência de Resultados Anteriores</h2>
                <svg class="h-6 w-6 text-gray-500 dark:text-gray-400 toggle-btn" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
            <div id="frequencyContainer" class="transition-height bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded" style="max-height: 500px; overflow: hidden;">
                <div class="p-4">
                    <div class="mb-4">
                        <label class="block mb-1">Cole os resultados do Dia de Sorte (um por linha, números separados por espaço):</label>
                        <textarea id="historicalResults" rows="6" placeholder="Ex: 01 03 07 13 18 27 29 Jan
04 07 09 10 14 20 25 Fev" class="w-full p-2 border rounded dark:bg-gray-800 dark:border-gray-700 text-base"></textarea>
                        <div class="text-xs text-gray-500 dark:text-gray-400 mt-1">
                            Formato: "01 02 03 04 05 06 07 Jan" (incluindo o mês da sorte ao final se disponível)
                        </div>
                    </div>
                    <div class="flex flex-wrap gap-2 mb-4">
                        <button id="analyzeBtn" class="bg-primary hover:bg-primary/90 text-white font-bold py-2 px-4 rounded">
                            Analisar Frequência
                        </button>
						<div class="flex flex-col sm:flex-row gap-2 flex-grow">
							<div class="p-2 bg-gray-200 dark:bg-gray-700 rounded text-gray-700 dark:text-gray-300 text-sm">
								Usando API Caixa via Proxy CORS
							</div>
						</div>
						<div class="flex gap-2 mb-4">
							<button id="fetchResultsBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded flex items-center">
								<span id="fetchText">Buscar Resultados</span>
								<span id="loadingSpinner" class="spinner ml-2 hidden"></span>
							</button>
							<button id="updateCacheBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded flex items-center">
								<span id="updateCacheText">Atualizar Cache</span>
								<span id="cacheInfo" class="text-xs ml-2"></span>
							</button>
						</div>						
                    </div>
                    <div id="apiStatus" class="mb-4 p-3 bg-gray-100 dark:bg-gray-700 rounded hidden">
                        <div class="font-semibold mb-1">Status da busca:</div>
                        <div id="apiStatusContent" class="text-sm"></div>
                    </div>
                    <div id="frequencyAnalysis" class="mt-4">
                        <div id="frequencyResults" class="hidden">
                            <h3 class="text-lg font-semibold mb-2">Frequência de Dígitos</h3>
                            <div id="topCombinations" class="bg-gray-100 dark:bg-gray-700 p-3 rounded mb-3">
                                <!-- Será preenchido com as combinações mais frequentes -->
                            </div>
                            
                            <!-- NOVA SEÇÃO: Estatística de dezenas por categoria -->
                            <div id="numberCategoryStats" class="bg-indigo-900 p-3 rounded mb-3 text-center">
                                <div class="font-bold text-xl mb-3 text-white">Estatística de Dezenas nos Sorteios Anteriores</div>
                                <div class="stat-bars-container flex justify-center items-end h-20 mb-1 gap-4">
                                    <div class="stat-bar-group flex flex-col items-center">
                                        <div id="lowBar" class="bg-green-500 w-32 text-white font-bold flex justify-center items-center" style="height: 0%">57%</div>
                                        <div class="text-sm text-white mt-1">4 dezenas<br>baixas</div>
                                    </div>
                                    <div class="stat-bar-group flex flex-col items-center">
                                        <div id="mediumBar" class="bg-yellow-600 w-32 text-white font-bold flex justify-center items-center" style="height: 0%">14%</div>
                                        <div class="text-sm text-white mt-1">1 dezenas<br>Médias</div>
                                    </div>
                                    <div class="stat-bar-group flex flex-col items-center">
                                        <div id="highBar" class="bg-red-600 w-32 text-white font-bold flex justify-center items-center" style="height: 0%">29%</div>
                                        <div class="text-sm text-white mt-1">2 dezenas<br>Altas</div>
                                    </div>
                                </div>
                                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-3 mb-3">
                                    <div class="bg-green-800 p-3 rounded-lg text-left">
                                        <div class="font-bold text-white">Baixas (1-10)</div>
                                        <div id="lowNumberStats" class="text-green-200"></div>
                                    </div>
                                    <div class="bg-yellow-700 p-3 rounded-lg text-left">
                                        <div class="font-bold text-white">Médias (11-20)</div>
                                        <div id="mediumNumberStats" class="text-yellow-200"></div>
                                    </div>
                                    <div class="bg-red-800 p-3 rounded-lg text-left">
                                        <div class="font-bold text-white">Altas (21-31)</div>
                                        <div id="highNumberStats" class="text-red-200"></div>
                                    </div>
                                </div>
                                <div class="text-sm text-gray-300 italic">
                                    Esta estatística mostra a frequência de cada categoria de dezenas nos sorteios analisados.
                                    Use-a para ajustar sua estratégia de distribuição.
                                </div>
                            </div>
                            
                            <!-- NOVA SEÇÃO: Frequência por dezena -->
                            <div id="numberFrequencyStats" class="bg-purple-900 p-3 rounded mb-3">
                                <div class="font-bold text-xl mb-3 text-white">Frequência de Cada Dezena</div>
                                <div id="numberFrequencyGrid" class="frequency-grid gap-3 mb-3">
                                    <!-- Será preenchido dinamicamente com as dezenas e suas frequências -->
                                </div>
                                <div class="text-sm text-gray-300 italic text-center mt-2">
                                    Esta estatística mostra quantas vezes cada dezena apareceu nos sorteios analisados.
                                    O número mais frequente está destacado com animação pulsante.
                                </div>
                            </div>
                            
                            <!-- NOVA SEÇÃO: Frequência dos meses da sorte -->
                            <div id="monthFrequencyStats" class="bg-indigo-800 p-3 rounded mb-3">
                                <div class="font-bold text-xl mb-3 text-white">Frequência do Mês da Sorte</div>
                                <div class="grid grid-cols-2 md:grid-cols-4 gap-3 mb-3">
                                    <div id="monthJan" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Janeiro</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthFev" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Fevereiro</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthMar" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Março</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthAbr" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Abril</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthMai" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Maio</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthJun" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Junho</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthJul" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Julho</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthAgo" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Agosto</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthSet" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Setembro</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthOut" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Outubro</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthNov" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Novembro</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthDez" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Dezembro</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                </div>
                                <div class="text-sm text-gray-300 italic text-center">
                                    Estatística dos meses da sorte que mais aparecem nos sorteios anteriores.
                                </div>
                            </div>
                            
                            <!-- NOVA SEÇÃO: Padrões de dígitos (início igual e final igual) -->
                            <div id="digitPatternsStats" class="bg-teal-900 p-3 rounded mb-3">
                                <div class="font-bold text-xl mb-3 text-white">Padrões de Dígitos nos Sorteios</div>
                                
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                                    <!-- Dígitos iniciais (primeiro dígito) -->
                                    <div class="bg-teal-800 p-3 rounded-lg">
                                        <div class="font-bold text-lg text-white mb-2">Dígitos Iniciais</div>
                                        <div id="startDigitStats" class="space-y-2">
                                            <!-- Mostrar apenas os 10 padrões mais frequentes -->
                                            <div id="topStartDigitPatterns"></div>
                                            <!-- Botão para mostrar/ocultar mais padrões -->
                                            <div id="moreStartDigitPatterns" class="hidden-patterns">
                                                <!-- Os padrões adicionais serão inseridos aqui -->
                                            </div>
                                            <div id="showMoreStartBtn" class="show-more-btn">Mostrar Mais</div>
                                        </div>
                                    </div>

                                    <!-- Dígitos finais (último dígito) -->
                                    <div class="bg-teal-800 p-3 rounded-lg">
                                        <div class="font-bold text-lg text-white mb-2">Dígitos Finais</div>
                                        <div id="endDigitStats" class="space-y-2">
                                            <!-- Mostrar apenas os 10 padrões mais frequentes -->
                                            <div id="topEndDigitPatterns"></div>
                                            <!-- Botão para mostrar/ocultar mais padrões -->
                                            <div id="moreEndDigitPatterns" class="hidden-patterns">
                                                <!-- Os padrões adicionais serão inseridos aqui -->
                                            </div>
                                            <div id="showMoreEndBtn" class="show-more-btn">Mostrar Mais</div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="bg-teal-800 p-3 rounded-lg mb-3">
                                    <div class="font-bold text-lg text-white mb-2">Combinações Frequentes</div>
                                    <div id="frequentPatterns" class="overflow-x-auto">
                                        <table class="min-w-full text-white">
                                            <thead>
                                                <tr>
                                                    <th class="px-3 py-2 text-left">Exemplo</th>
                                                    <th class="px-3 py-2 text-left">Padrão Inicial</th>
                                                    <th class="px-3 py-2 text-left">Padrão Final</th>
                                                    <th class="px-3 py-2 text-left">Ocorrências</th>
                                                </tr>
                                            </thead>
                                            <tbody id="patternExamples">
                                                <!-- Será preenchido dinamicamente -->
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                                
                                <!-- Nova seção para seleção de padrões específicos -->
                                <div class="bg-teal-800 p-3 rounded-lg mb-3">
                                    <div class="font-bold text-lg text-white mb-2">Gerar Palpites com Padrões Específicos</div>
                                    
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                                        <div>
                                            <div class="text-white mb-2">Selecione os Padrões Iniciais:</div>
                                            <div id="startPatternSelectors" class="pattern-selector overflow-y-auto max-h-48">
                                                <!-- Checkboxes serão inseridos aqui -->
                                            </div>
                                        </div>
                                        <div>
                                            <div class="text-white mb-2">Selecione os Padrões Finais:</div>
                                            <div id="endPatternSelectors" class="pattern-selector overflow-y-auto max-h-48">
                                                <!-- Checkboxes serão inseridos aqui -->
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div class="mt-4 mb-4">
                                        <div class="text-white mb-2">Quantidade de palpites a gerar:</div>
                                        <input type="number" id="patternBetCount" value="5" min="1" max="20" class="p-2 border rounded w-full bg-teal-700 border-teal-600 text-white">
                                    </div>
                                    
                                    <div class="flex justify-between">
                                        <button id="generateFromSelectedPatternsBtn" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded">
                                            Gerar Palpites dos Padrões Selecionados
                                        </button>
                                        <div class="flex gap-2">
                                            <button id="downloadPatternSimpleBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                                                Somente Dezenas
                                            </button>
                                            <button id="downloadPatternDetailedBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                                                Baixar Detalhado
                                            </button>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="flex justify-end">
                                    <button id="generateFromPatternBtn" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded">
                                        Gerar Palpites baseados nos Padrões Frequentes
                                    </button>
                                </div>
                                
                                <div class="text-sm text-gray-300 italic text-center mt-3">
                                    Esta estatística analisa os padrões de dígitos nos sorteios anteriores.
                                    Por exemplo: "3n 0" significa 3 números começando com dígito 0.
                                </div>
                            </div>
                            
                            <!-- Novo painel para combinações não sorteadas -->
                            <div id="undrawnCombinations" class="bg-blue-100 dark:bg-blue-900 p-3 rounded mb-3">
                                <div class="font-bold text-xl mb-3 text-blue-800 dark:text-blue-200 flex items-center">
                                    Combinações Ainda Não Sorteadas
                                    <span class="text-sm font-bold ml-2 bg-blue-200 dark:bg-blue-700 text-blue-800 dark:text-blue-200 px-2 py-0.5 rounded-full" id="undrawnCountDisplay"></span>
                                </div>
                                <div id="undrawnCombinationsContent" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2">
                                    <!-- Será preenchido com as combinações não sorteadas -->
                                </div>
                                <div class="mt-3 flex justify-end">
                                    <button id="downloadUndrawnBtn" class="bg-blue-600 hover:bg-blue-700 text-white text-sm font-bold py-1 px-3 rounded">
                                        Baixar Lista
                                    </button>
                                </div>
                            </div>
                            
                            <div class="overflow-x-auto">
                                <table class="min-w-full divide-y divide-gray-300 dark:divide-gray-700">
                                    <thead>
                                        <tr class="bg-gray-100 dark:bg-gray-700">
                                            <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Combinação de Dígitos</th>
                                            <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Frequência</th>
                                            <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Porcentagem</th>
                                        </tr>
                                    </thead>
                                    <tbody id="frequencyTableBody" class="divide-y divide-gray-200 dark:divide-gray-700">
                                        <!-- Será preenchido dinamicamente -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Seção: Tabela de Combinações -->
        <div class="mb-8">
            <div class="flex items-center justify-between cursor-pointer mb-2" id="combinationsToggleHeader">
                <h2 class="text-xl font-semibold">Tabela de Combinações</h2>
                <svg class="h-6 w-6 text-gray-500 dark:text-gray-400 toggle-btn" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
            <div id="combinationsTableContainer" class="transition-height bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded overflow-x-auto" style="max-height: 0px;">
                <div id="combinationsTable">
                    <table class="min-w-full divide-y divide-gray-300 dark:divide-gray-700">
                        <thead>
                            <tr class="bg-gray-100 dark:bg-gray-700">
                                <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Dígitos</th>
                                <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Números Possíveis</th>
                                <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Total</th>
                            </tr>
                        </thead>
                        <tbody id="combinationsTableBody" class="divide-y divide-gray-200 dark:divide-gray-700">
                            <!-- Dynamic content will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Seção: Resumo Estatístico -->
        <div class="mb-8">
            <div class="flex items-center justify-between cursor-pointer mb-2" id="statsHeader">
                <h2 class="text-xl font-semibold">Resumo Estatístico</h2>
                <svg class="h-6 w-6 text-gray-500 dark:text-gray-400 toggle-btn" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
            <div id="statsContainer" class="transition-height bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded" style="max-height: 0px; overflow: hidden;">
                <div id="statisticsSummary" class="p-4">
                    <div id="statisticsContent" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <!-- Dynamic content will be inserted here -->
                    </div>
                    <div id="statisticsTotal" class="mt-4 font-bold border-t pt-2 dark:border-gray-700">
                        <!-- Total will be inserted here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Seção: Gerador por Combinação Específica -->
        <div class="mb-8">
            <div class="flex items-center justify-between cursor-pointer mb-2" id="specificHeader">
                <h2 class="text-xl font-semibold">Gerador por Combinação Específica</h2>
                <svg class="h-6 w-6 text-gray-500 dark:text-gray-400 toggle-btn" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
            <div id="specificContainer" class="transition-height bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded" style="max-height: 0px; overflow: hidden;">
                <div class="p-4">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="block mb-2">Selecione uma combinação de dígitos:</label>
                            <select id="specificCombination" class="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 text-base">
                                <!-- Será preenchido dinamicamente -->
                            </select>
                        </div>
                        <div>
                            <label class="block mb-2">Dezenas por palpite:</label>
                            <div class="flex gap-4">
                                <input type="number" id="specificNumberPerBet" value="7" min="5" max="15" class="p-2 border rounded w-full dark:bg-gray-700 dark:border-gray-600 text-base">
                                <button id="generateSpecificBtn" class="bg-primary hover:bg-primary/90 text-white font-bold py-2 px-4 rounded whitespace-nowrap">
                                    Gerar Palpites
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="mb-4">
                        <div class="bg-gray-100 dark:bg-gray-700 p-3 rounded">
                            <div class="flex items-center mb-2">
                                <span class="font-semibold mr-2">Dezenas possíveis para esta combinação:</span>
                                <span id="possibleNumberCount" class="bg-primary text-white px-3 py-1 rounded-full font-bold">0</span>
                            </div>
                            <div id="possibleNumbersDisplay" class="flex flex-wrap gap-2"></div>
                        </div>
                    </div>

                    <div class="mb-4 flex flex-wrap gap-2 justify-between items-center">
                        <div>
                            <span class="font-semibold">Total de palpites gerados: </span>
                            <span id="specificBetCount" class="bg-primary/10 dark:bg-primary/20 text-primary px-2 py-1 rounded-full font-bold">0</span>
                        </div>
                        <div class="flex gap-2">
                            <button id="downloadSpecificSimpleBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded flex items-center disabled:opacity-50 disabled:cursor-not-allowed">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                                </svg>
                                Somente Dezenas
                            </button>
                            <button id="downloadSpecificBtn" class="bg-primary hover:bg-primary/90 text-white font-bold py-2 px-4 rounded flex items-center disabled:opacity-50 disabled:cursor-not-allowed">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                                </svg>
                                Baixar Detalhado
                            </button>
                        </div>
                    </div>

                    <div id="specificBetsResults" class="border-t dark:border-gray-700 pt-4">
                        <div id="specificResultsContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            <!-- Resultados dinâmicos serão mostrados aqui -->
                        </div>
                        
                        <!-- Paginação -->
                        <div id="paginationContainer" class="mt-6 flex justify-center items-center space-x-2">
                            <button id="prevPageBtn" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                                Anterior
                            </button>
                            <span id="paginationInfo" class="text-sm px-2">Página 1 de 1</span>
                            <button id="nextPageBtn" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                                Próxima
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
		<!-- Seção: Misturador de Palpites (NOVA) -->
		<div class="mb-8">
			<div class="flex items-center justify-between cursor-pointer mb-2" id="mixerHeader">
				<h2 class="text-xl font-semibold flex items-center">
					<span>Misturador de Palpites</span> 
					<span class="text-sm font-bold ml-2 bg-blue-100 dark:bg-blue-800 text-blue-800 dark:text-blue-200 px-2 py-0.5 rounded-full">NOVO</span>
				</h2>
				<svg class="h-6 w-6 text-gray-500 dark:text-gray-400 toggle-btn" fill="none" viewBox="0 0 24 24" stroke="currentColor">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
				</svg>
			</div>
			<div id="mixerContainer" class="transition-height bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded" style="max-height: 0px; overflow: hidden;">
				<div class="p-4">
					<div class="mb-6 bg-blue-50 dark:bg-blue-900 p-4 rounded-lg">
						<h3 class="text-lg font-semibold text-blue-800 dark:text-blue-200 mb-2">Crie um Conjunto Personalizado de Palpites</h3>
						<p class="text-blue-700 dark:text-blue-300 mb-3">
							Esta funcionalidade permite combinar palpites de diferentes seções do aplicativo. Você pode selecionar quantos palpites deseja 
							de cada seção e criar um conjunto personalizado que mistura diversas estratégias.
						</p>
					</div>
					
					<div class="mb-4">
						<label class="block font-medium mb-2">Quantidade total de palpites a gerar:</label>
						<input type="number" id="totalMixedBets" min="1" max="50" value="20" class="p-2 border rounded w-full sm:w-48 dark:bg-gray-700 dark:border-gray-600 text-base">
					</div>
					
					<div class="space-y-4">
						<div class="mixer-section">
							<h3 class="text-lg font-semibold mb-3">Selecione a quantidade de palpites de cada seção:</h3>
							
							<div class="grid grid-cols-1 md:grid-cols-2 gap-4">
								<div class="mixer-card">
									<div class="flex justify-between items-center mb-2">
										<h4 class="font-medium">Seção Configurações</h4>
										<div class="text-xs px-2 py-1 bg-gray-200 dark:bg-gray-700 rounded-full">Geral</div>
									</div>
									<p class="text-sm text-gray-600 dark:text-gray-400 mb-2">Palpites baseados nas configurações gerais, utilizando combinações não sorteadas.</p>
									<div class="flex items-center">
										<label class="mr-2">Quantidade:</label>
										<input type="number" id="configMixBets" min="0" value="1" class="p-1 border rounded w-16 dark:bg-gray-700 dark:border-gray-600 text-base">
									</div>
								</div>
								
								<div class="mixer-card">
									<div class="flex justify-between items-center mb-2">
										<h4 class="font-medium">Seção Palpites Gerados</h4>
										<div class="text-xs px-2 py-1 bg-gray-200 dark:bg-gray-700 rounded-full">Geral</div>
									</div>
									<p class="text-sm text-gray-600 dark:text-gray-400 mb-2">Palpites já gerados anteriormente na seção de Palpites Gerados.</p>
									<div class="flex items-center">
										<label class="mr-2">Quantidade:</label>
										<input type="number" id="generatedMixBets" min="0" value="5" class="p-1 border rounded w-16 dark:bg-gray-700 dark:border-gray-600 text-base">
									</div>
								</div>
								
								<div class="mixer-card">
									<div class="flex justify-between items-center mb-2">
										<h4 class="font-medium">Padrões de Dígitos</h4>
										<div class="text-xs px-2 py-1 bg-indigo-100 dark:bg-indigo-900 text-indigo-800 dark:text-indigo-200 rounded-full">Estatístico</div>
									</div>
									<p class="text-sm text-gray-600 dark:text-gray-400 mb-2">Palpites baseados nos padrões de dígitos mais frequentes nos sorteios anteriores.</p>
									<div class="flex items-center">
										<label class="mr-2">Quantidade:</label>
										<input type="number" id="patternMixBets" min="0" value="5" class="p-1 border rounded w-16 dark:bg-gray-700 dark:border-gray-600 text-base">
									</div>
								</div>
								
								<div class="mixer-card">
									<div class="flex justify-between items-center mb-2">
										<h4 class="font-medium">Combinação Específica</h4>
										<div class="text-xs px-2 py-1 bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 rounded-full">Dirigido</div>
									</div>
									<p class="text-sm text-gray-600 dark:text-gray-400 mb-2">Palpites baseados na combinação específica de dígitos selecionada.</p>
									<div class="flex items-center">
										<label class="mr-2">Quantidade:</label>
										<input type="number" id="specificMixBets" min="0" value="9" class="p-1 border rounded w-16 dark:bg-gray-700 dark:border-gray-600 text-base">
									</div>
								</div>
							</div>
							
							<div class="mt-4 p-3 bg-yellow-50 dark:bg-yellow-900 rounded-lg text-yellow-800 dark:text-yellow-200 text-sm">
								<p>Os totais da distribuição são ajustados automaticamente para atingir o número total desejado de palpites.</p>
							</div>
						</div>
					</div>
					
					<div class="flex gap-2 mt-6 mb-4">
						<button id="generateMixedBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded">
							Gerar Palpites Misturados
						</button>
					</div>
					
					<div id="mixedBetsContainer" class="mt-5 hidden">
						<div class="flex justify-between items-center mb-4">
							<h3 class="text-lg font-semibold">Palpites Misturados Gerados</h3>
							<div class="flex gap-2">
								<button id="downloadMixedSimpleBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded flex items-center">
									<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
										<path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
									</svg>
									Somente Dezenas
								</button>
								<button id="downloadMixedDetailedBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded flex items-center">
									<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
										<path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
									</svg>
									Baixar Detalhado
								</button>
							</div>
						</div>
						
						<div id="mixedResultsContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
							<!-- Resultados dinâmicos serão mostrados aqui -->
						</div>
					</div>
				</div>
			</div>
		</div>
        <!-- Seção: Palpites Gerados -->
        <div class="mb-8">
            <div class="flex items-center justify-between cursor-pointer mb-2" id="resultsHeader">
                <h2 class="text-xl font-semibold">Palpites Gerados (<span id="totalBetsCount">0</span> palpites)</h2>
                <svg class="h-6 w-6 text-gray-500 dark:text-gray-400 toggle-btn" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
            <div id="resultsContainer" class="transition-height bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded" style="max-height: 500px; overflow: hidden;">
                <div class="p-4">
                    <div class="mb-4 flex flex-wrap gap-2 justify-between items-center">
                        <div class="flex flex-wrap gap-2">
                            <div class="bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 px-3 py-1 rounded-full text-sm font-medium">
                                Baixas (1-10): <span id="lowCount">0</span>
                            </div>
                            <div class="bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 px-3 py-1 rounded-full text-sm font-medium">
                                Médias (11-20): <span id="mediumCount">0</span>
                            </div>
                            <div class="bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200 px-3 py-1 rounded-full text-sm font-medium">
                                Altas (21-31): <span id="highCount">0</span>
                            </div>
                        </div>
                        <div class="flex gap-2">
                            <button id="downloadSimpleBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                                </svg>
                                Somente Dezenas
                            </button>
                            <button id="downloadBtn" class="bg-primary hover:bg-primary/90 text-white font-bold py-2 px-4 rounded flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                                </svg>
                                Baixar Detalhado
                            </button>
                        </div>
                    </div>
                    
                    <div class="mb-4">
                        <div class="flex border-b dark:border-gray-700">
                            <button id="allBetsTab" class="py-2 px-4 font-medium border-b-2 border-primary text-primary">Todos</button>
                            <button id="lowBetsTab" class="py-2 px-4 font-medium text-gray-600 dark:text-gray-400">Baixas</button>
                            <button id="mediumBetsTab" class="py-2 px-4 font-medium text-gray-600 dark:text-gray-400">Médias</button>
                            <button id="highBetsTab" class="py-2 px-4 font-medium text-gray-600 dark:text-gray-400">Altas</button>
                        </div>
                    </div>
                    
                    <div id="bettingResults" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <!-- Dynamic content will be inserted here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Modal functions
            const modal = document.getElementById('instructionsModal');
            const showModalBtn = document.getElementById('showInstructionsBtn');
            const closeModalBtn = document.getElementById('closeModalBtn');
            const closeModalX = document.getElementById('closeModal');
			const mixerSection = setupCollapsibleSection('mixerHeader', 'mixerContainer', false); // Nova seção do misturador
            
			// Configurar o botão para atualizar o cache
			document.getElementById('updateCacheBtn').addEventListener('click', function() {
				fetchResultsFromAPIs(true); // Forçar atualização do cache
			});

			// Atualizar informações do botão de cache na inicialização
			updateCacheButton();
			
            // Show modal
            showModalBtn.addEventListener('click', function() {
                modal.style.display = 'block';
                document.body.style.overflow = 'hidden'; // Prevent scrolling behind modal
            });
            
            // Close modal with button
            closeModalBtn.addEventListener('click', function() {
                modal.style.display = 'none';
                document.body.style.overflow = 'auto'; // Re-enable scrolling
            });
            
            // Close modal with X
            closeModalX.addEventListener('click', function() {
                modal.style.display = 'none';
                document.body.style.overflow = 'auto'; // Re-enable scrolling
            });
            
            // Close modal when clicking outside
            window.addEventListener('click', function(event) {
                if (event.target === modal) {
                    modal.style.display = 'none';
                    document.body.style.overflow = 'auto'; // Re-enable scrolling
                }
            });
            
            // Função para gerenciar a distribuição por faixa
            function setupRangeDistribution() {
                const numberPerBetInput = document.getElementById('numberPerBet');
                const lowRangeInput = document.getElementById('lowRange');
                const mediumRangeInput = document.getElementById('mediumRange');
                const highRangeInput = document.getElementById('highRange');
                
                // Variável para armazenar o último campo modificado
                let lastModified = null;
                
                // Função para ajustar os valores mantendo a soma igual ao total
                function adjustValues(changedInput) {
                    // Armazenar o último campo alterado
                    lastModified = changedInput;
                    
                    const targetTotal = parseInt(numberPerBetInput.value);
                    
                    // Limitar os valores aos limites permitidos (0 a targetTotal)
                    let lowVal = Math.max(0, Math.min(targetTotal, parseInt(lowRangeInput.value) || 0));
                    let mediumVal = Math.max(0, Math.min(targetTotal, parseInt(mediumRangeInput.value) || 0));
                    let highVal = Math.max(0, Math.min(targetTotal, parseInt(highRangeInput.value) || 0));
                    
                    // Atualizar os valores nos campos se foram corrigidos
                    lowRangeInput.value = lowVal;
                    mediumRangeInput.value = mediumVal;
                    highRangeInput.value = highVal;
                    
                    const currentTotal = lowVal + mediumVal + highVal;
                    
                    // Se o total já está correto, não precisa ajustar
                    if (currentTotal === targetTotal) {
                        updateDistributionSummary();
                        return;
                    }
                    
                    // Determinar qual ajuste é necessário
                    const difference = targetTotal - currentTotal;
                    
                    // Prioridade de ajuste: manter o valor do último campo alterado
                    if (changedInput === numberPerBetInput) {
                        // Se mudar o número total de dezenas, ajustar proporcionalmente todos os campos
                        if (currentTotal === 0) {
                            // Se todos estão zerados, colocar tudo em baixas
                            lowRangeInput.value = targetTotal;
                            mediumRangeInput.value = 0;
                            highRangeInput.value = 0;
                        } else {
                            // Distribuição proporcional
                            const factor = targetTotal / currentTotal;
                            
                            // Calcular novos valores mantendo proporções aproximadas
                            let newLow = Math.round(lowVal * factor);
                            let newMedium = Math.round(mediumVal * factor);
                            let newHigh = targetTotal - newLow - newMedium;
                            
                            // Ajustar se necessário para garantir valores não negativos
                            newLow = Math.max(0, newLow);
                            newMedium = Math.max(0, newMedium);
                            newHigh = Math.max(0, newHigh);
                            
                            // Garantir que a soma seja exatamente igual ao alvo
                            const adjustedTotal = newLow + newMedium + newHigh;
                            if (adjustedTotal !== targetTotal) {
                                // Ajustar o último valor para garantir a soma correta
                                newHigh = targetTotal - newLow - newMedium;
                            }
                            
                            // Aplicar os novos valores
                            lowRangeInput.value = newLow;
                            mediumRangeInput.value = newMedium;
                            highRangeInput.value = newHigh;
                        }
                    } 
                    else if (changedInput === lowRangeInput) {
                        // Se o usuário aumentou além do permitido, os outros campos serão zerados
                        if (lowVal >= targetTotal) {
                            mediumRangeInput.value = 0;
                            highRangeInput.value = 0;
                            
                            // Garantir que o total seja exato
                            lowRangeInput.value = targetTotal;
                        } else {
                            // Distribuir a diferença entre os outros campos, proporcionalmente
                            const remainingTotal = mediumVal + highVal;
                            if (remainingTotal === 0) {
                                // Se os outros campos estão zerados, colocar tudo em um deles
                                mediumRangeInput.value = 0;
                                highRangeInput.value = targetTotal - lowVal;
                            } else {
                                // Proporção atual entre médio e alto
                                const mediumRatio = mediumVal / remainingTotal;
                                
                                // Calcular novos valores
                                const remaining = targetTotal - lowVal;
                                const newMedium = Math.round(remaining * mediumRatio);
                                const newHigh = remaining - newMedium;
                                
                                // Aplicar os novos valores
                                mediumRangeInput.value = newMedium;
                                highRangeInput.value = newHigh;
                            }
                        }
                    } 
                    else if (changedInput === mediumRangeInput) {
                        // Se o usuário aumentou além do permitido, os outros campos serão zerados
                        if (mediumVal >= targetTotal) {
                            lowRangeInput.value = 0;
                            highRangeInput.value = 0;
                            
                            // Garantir que o total seja exato
                            mediumRangeInput.value = targetTotal;
                        } else {
                            // Distribuir a diferença entre os outros campos, proporcionalmente
                            const remainingTotal = lowVal + highVal;
                            if (remainingTotal === 0) {
                                // Se os outros campos estão zerados, colocar tudo em um deles
                                lowRangeInput.value = targetTotal - mediumVal;
                                highRangeInput.value = 0;
                            } else {
                                // Proporção atual entre baixo e alto
                                const lowRatio = lowVal / remainingTotal;
                                
                                // Calcular novos valores
                                const remaining = targetTotal - mediumVal;
                                const newLow = Math.round(remaining * lowRatio);
                                const newHigh = remaining - newLow;
                                
                                // Aplicar os novos valores
                                lowRangeInput.value = newLow;
                                highRangeInput.value = newHigh;
                            }
                        }
                    } 
                    else if (changedInput === highRangeInput) {
                        // Se o usuário aumentou além do permitido, os outros campos serão zerados
                        if (highVal >= targetTotal) {
                            lowRangeInput.value = 0;
                            mediumRangeInput.value = 0;
                            
                            // Garantir que o total seja exato
                            highRangeInput.value = targetTotal;
                        } else {
                            // Distribuir a diferença entre os outros campos, proporcionalmente
                            const remainingTotal = lowVal + mediumVal;
                            if (remainingTotal === 0) {
                                // Se os outros campos estão zerados, colocar tudo em um deles
                                lowRangeInput.value = targetTotal - highVal;
                                mediumRangeInput.value = 0;
                            } else {
                                // Proporção atual entre baixo e médio
                                const lowRatio = lowVal / remainingTotal;
                                
                                // Calcular novos valores
                                const remaining = targetTotal - highVal;
                                const newLow = Math.round(remaining * lowRatio);
                                const newMedium = remaining - newLow;
                                
                                // Aplicar os novos valores
                                lowRangeInput.value = newLow;
                                mediumRangeInput.value = newMedium;
                            }
                        }
                    }
                    
                    // Verificar novamente se o total está correto após ajustes
                    const finalLow = parseInt(lowRangeInput.value) || 0;
                    const finalMedium = parseInt(mediumRangeInput.value) || 0;
                    const finalHigh = parseInt(highRangeInput.value) || 0;
                    const finalTotal = finalLow + finalMedium + finalHigh;
                    
                    if (finalTotal !== targetTotal) {
                        // Ajuste final se necessário
                        const finalDiff = targetTotal - finalTotal;
                        
                        // Ajustar o campo que não foi modificado pelo usuário
                        if (changedInput !== lowRangeInput && finalLow + finalDiff >= 0) {
                            lowRangeInput.value = finalLow + finalDiff;
                        } else if (changedInput !== mediumRangeInput && finalMedium + finalDiff >= 0) {
                            mediumRangeInput.value = finalMedium + finalDiff;
                        } else if (changedInput !== highRangeInput && finalHigh + finalDiff >= 0) {
                            highRangeInput.value = finalHigh + finalDiff;
                        }
                    }
                    
                    // Atualizar a descrição na interface
                    updateDistributionSummary();
                }
                
                // Função para mostrar um resumo da distribuição atual
                function updateDistributionSummary() {
                    const totalDezenas = parseInt(numberPerBetInput.value);
                    const lowVal = parseInt(lowRangeInput.value) || 0;
                    const mediumVal = parseInt(mediumRangeInput.value) || 0;
                    const highVal = parseInt(highRangeInput.value) || 0;
                    
                    const distributionSummary = document.getElementById('distributionSummary');
                    if (distributionSummary) {
                        distributionSummary.textContent = `Total: ${lowVal + mediumVal + highVal}/${totalDezenas} dezenas`;
                        
                        // Destacar se a soma não estiver correta (não deve acontecer com o auto-ajuste)
                        if (lowVal + mediumVal + highVal !== totalDezenas) {
                            distributionSummary.classList.add('text-red-500');
                        } else {
                            distributionSummary.classList.remove('text-red-500');
                        }
                    }
                }
                
                // Adicionar event listeners
                lowRangeInput.addEventListener('change', () => adjustValues(lowRangeInput));
                mediumRangeInput.addEventListener('change', () => adjustValues(mediumRangeInput));
                highRangeInput.addEventListener('change', () => adjustValues(highRangeInput));
                numberPerBetInput.addEventListener('change', () => adjustValues(numberPerBetInput));
                
                // Também ajustar quando o usuário digita
                lowRangeInput.addEventListener('input', () => adjustValues(lowRangeInput));
                mediumRangeInput.addEventListener('input', () => adjustValues(mediumRangeInput));
                highRangeInput.addEventListener('input', () => adjustValues(highRangeInput));
                
                // Inicializar o resumo da distribuição
                updateDistributionSummary();
            }
            
            // Configurações das APIs
            const API_CONFIG = {
                // APIs oficiais
                CAIXA_URL: 'https://servicebus2.caixa.gov.br/portaldeloterias/api/diadesorte',
                HEROKU_URL: 'https://loteriascaixa-api.herokuapp.com/api/dia-de-sorte',
                BRASIL_URL: 'https://brasilapi.com.br/api/loterias/v1/dia-de-sorte',
                
                // Serviços de proxy CORS alternativos - Adicionados mais proxies
                CORS_PROXY_URLS: [
                    'https://corsproxy.io/?',
                    'https://api.allorigins.win/raw?url=',
                    'https://cors-anywhere.herokuapp.com/',
                    'https://proxy.cors.sh/',
                    'https://cors.bridged.cc/',
                    'https://crossorigin.me/',
                    'https://thingproxy.freeboard.io/fetch/'
                ]
            };
            
            // Configuração para todas as seções expansíveis
            function setupCollapsibleSection(headerId, containerId, initiallyExpanded = false) {
                const header = document.getElementById(headerId);
                const container = document.getElementById(containerId);
                const toggleBtn = header.querySelector('.toggle-btn');
                
                // Remover a transição temporariamente para configuração inicial
                container.style.transition = 'none';
                
                // Estado inicial
                if (!initiallyExpanded) {
                    container.style.maxHeight = '0px';
                    container.style.overflow = 'hidden';
                } else {
                    container.style.maxHeight = '5000px'; // Valor bem grande para acomodar conteúdo
                    toggleBtn.classList.add('active');
                }
                
                // Forçar reflow e restaurar transição
                container.offsetHeight; 
                container.style.transition = 'max-height 0.5s ease-out';
                
                // Adicionar evento de clique
                header.addEventListener('click', function() {
                    // Alternar classe active no botão
                    toggleBtn.classList.toggle('active');
                    
                    if (container.style.maxHeight === '0px') {
                        // Abrir a seção
                        container.style.maxHeight = '5000px'; // Valor grande suficiente para qualquer conteúdo
                        
                        // Log para debug
                        console.log(`Abrindo ${headerId}`);
                    } else {
                        // Fechar a seção
                        container.style.maxHeight = '0px';
                        
                        // Log para debug
                        console.log(`Fechando ${headerId}`);
                    }
                });
                
                // Métodos para manipular a seção
                return {
                    updateHeight: function() {
                        if (container.style.maxHeight !== '0px') {
                            // Redefinir altura para acomodar conteúdo novo
                            container.style.maxHeight = '5000px';
                            console.log(`Atualizando altura de ${headerId}`);
                        }
                    },
                    forceOpen: function() {
                        toggleBtn.classList.add('active');
                        container.style.maxHeight = '5000px';
                        console.log(`Forçando abertura de ${headerId}`);
                    },
                    forceClose: function() {
                        toggleBtn.classList.remove('active');
                        container.style.maxHeight = '0px';
                        console.log(`Forçando fechamento de ${headerId}`);
                    }
                };
            }
            
            // Configurar todas as seções expansíveis
            const digitCombinationsSection = setupCollapsibleSection('digitCombinationsHeader', 'digitCombinationsContainer', false);
            const configSection = setupCollapsibleSection('configHeader', 'configContainer', true);
            const frequencySection = setupCollapsibleSection('frequencyHeader', 'frequencyContainer', true);
            const combinationsSection = setupCollapsibleSection('combinationsToggleHeader', 'combinationsTableContainer', false);
            const statsSection = setupCollapsibleSection('statsHeader', 'statsContainer', false);
            const specificSection = setupCollapsibleSection('specificHeader', 'specificContainer', false);
            const resultsSection = setupCollapsibleSection('resultsHeader', 'resultsContainer', true);
            
            // Corrigir o problema das seções que não abrem, forçando a inicialização
            setTimeout(() => {
                document.querySelectorAll('.transition-height').forEach(el => {
                    // Preservar o estado atual
                    const wasHidden = el.style.maxHeight === '0px';
                    
                    // Forçar a recalcular corretamente as alturas
                    if (wasHidden) {
                        el.style.maxHeight = 'auto';
                        const autoHeight = el.scrollHeight + 'px';
                        el.style.maxHeight = '0px';
                        
                        // Armazenar a altura real para uso posterior
                        el.dataset.fullHeight = autoHeight;
                    } else {
                        el.style.maxHeight = el.scrollHeight + 'px';
                    }
                });
            }, 500);
            
            // Armazenamento de cache local para dados das APIs
            const LOCAL_CACHE = {
                setCached: function(key, data, expiresInMinutes = 60) {
                    try {
                        const item = {
                            data: data,
                            expires: new Date().getTime() + expiresInMinutes * 60 * 1000
                        };
                        localStorage.setItem(key, JSON.stringify(item));
                        return true;
                    } catch (e) {
                        console.error("Erro ao armazenar em cache:", e);
                        return false;
                    }
                },
                
                getCached: function(key) {
                    try {
                        const item = JSON.parse(localStorage.getItem(key));
                        if (!item) return null;
                        
                        // Verifica se expirou
                        if (new Date().getTime() > item.expires) {
                            localStorage.removeItem(key);
                            return null;
                        }
                        
                        return item.data;
                    } catch (e) {
                        console.error("Erro ao recuperar cache:", e);
                        return null;
                    }
                },
                
                removeCache: function(key) {
                    try {
                        localStorage.removeItem(key);
                        return true;
                    } catch (e) {
                        console.error("Erro ao remover cache:", e);
                        return false;
                    }
                }
            };

            // Função para gerar TODAS as combinações possíveis de 5 dígitos
            function generateAllDigitCombinations() {
                const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
                const combinations = [];
                
                // Função auxiliar para gerar combinações de k elementos de um array
                function combinate(arr, k, startIndex, currentCombination, result) {
                    if (currentCombination.length === k) {
                        result.push([...currentCombination]);
                        return;
                    }
                    
                    for (let i = startIndex; i < arr.length; i++) {
                        currentCombination.push(arr[i]);
                        combinate(arr, k, i + 1, currentCombination, result);
                        currentCombination.pop();
                    }
                }
                
                // Gerar combinações de 5 dígitos
                combinate(digits, 5, 0, [], combinations);
                
                // Converter para formato de string (ex: "0,1,2,3,4")
                return combinations.map(combo => combo.join(','));
            }

            // Função para filtrar combinações inválidas para Dia de Sorte
            function filterValidCombinations(allCombinations) {
                // Apenas 126 das 252 combinações são válidas para o Dia de Sorte
                // Esta é apenas uma implementação de exemplo - a lógica real depende das regras específicas
                // Retornamos as mesmas 126 combinações que o usuário forneceu
                
                const validCombinations = [
                    "0,1,2,3,4", "0,1,2,3,5", "0,1,2,3,6", "0,1,2,3,7", "0,1,2,3,8", "0,1,2,3,9", 
                    "0,1,2,4,5", "0,1,2,4,6", "0,1,2,4,7", "0,1,2,4,8", "0,1,2,4,9", "0,1,2,5,6",     
                    "0,1,2,5,7", "0,1,2,5,8", "0,1,2,5,9", "0,1,2,6,7", "0,1,2,6,8", "0,1,2,6,9",     
                    "0,1,2,7,8", "0,1,2,7,9", "0,1,2,8,9", "0,1,3,4,5", "0,1,3,4,6", "0,1,3,4,7",  
                    "0,1,3,4,8", "0,1,3,4,9", "0,1,3,5,6", "0,1,3,5,7", "0,1,3,5,8", "0,1,3,5,9",  
                    "0,1,3,6,7", "0,1,3,6,8", "0,1,3,6,9", "0,1,3,7,8", "0,1,3,7,9", "0,1,3,8,9",     
                    "0,1,4,5,6", "0,1,4,5,7", "0,1,4,5,8", "0,1,4,5,9", "0,1,4,6,7", "0,1,4,6,8",     
                    "0,1,4,6,9", "0,1,4,7,8", "0,1,4,7,9", "0,1,4,8,9", "0,1,5,6,7", "0,1,5,6,8",  
                    "0,1,5,7,9", "0,1,5,8,9", "0,1,6,7,8", "0,1,6,7,9", "0,1,6,8,9", "0,1,7,8,9",  
                    "0,2,3,4,7", "0,2,3,4,8", "0,2,3,4,9", "0,2,3,5,6", "0,2,3,5,7", "0,2,3,5,8",       
                    "0,2,3,6,8", "0,2,3,6,9", "0,2,3,7,8", "0,2,3,7,9", "0,2,3,8,9", "0,2,4,5,6",    
                    "0,2,4,6,8", "0,2,4,6,9", "0,2,4,7,8", "0,2,4,7,9", "0,2,4,8,9", "0,2,5,6,7",      
                    "0,2,5,7,8", "0,2,5,7,9", "0,2,5,8,9", "0,2,6,7,8", "0,2,6,7,9", "0,2,6,8,9",      
                    "1,2,3,4,6", "1,2,3,4,7", "1,2,3,4,8", "1,2,3,4,9", "1,2,3,5,6", "1,2,3,5,7",      
                    "1,2,3,6,8", "1,2,3,6,9", "1,2,3,7,8", "1,2,3,7,9", "1,2,3,8,9", "1,2,4,5,6",      
                    "1,2,4,5,9", "1,2,4,6,7", "1,2,4,6,8", "1,2,4,6,9", "1,2,4,7,8", "1,2,4,7,9",     
                    "1,2,5,6,8", "1,2,5,6,9", "1,2,5,7,8", "1,2,5,7,9", "1,2,5,8,9", "1,2,6,7,8",     
                    "1,2,6,7,9", "1,2,6,8,9", "1,2,7,8,9", "0,2,4,5,7", "0,2,4,5,8", "0,2,4,5,9",     
                    "0,2,4,6,7", "1,2,4,8,9", "1,2,5,6,7", "1,2,4,5,7", "1,2,4,5,8", "0,2,3,5,9",
                    "1,2,3,5,8", "1,2,3,5,9", "1,2,3,6,7", "0,2,7,8,9", "1,2,3,4,5", "0,2,3,6,7", 
                    "0,2,5,6,8", "0,2,5,6,9", "0,1,5,6,9", "0,1,5,7,8", "0,2,3,4,5", "0,2,3,4,6"
                ];
                
                console.log(`Total de combinações geradas: ${allCombinations.length}`);
                console.log(`Total de combinações válidas: ${validCombinations.length}`);
                
                return validCombinations;
            }

            // Gerar todas as combinações possíveis e filtrar as válidas
            const allPossibleCombinations = generateAllDigitCombinations();
            let validDigitCombinations = filterValidCombinations(allPossibleCombinations);
            
            // Fill the textarea with the valid combinations
            document.getElementById('digitCombinations').value = validDigitCombinations.join('\n');

            // Variáveis para armazenar todos os palpites gerados (para download)
            let allGeneratedBets = [];
            let lowBets = [];
            let mediumBets = [];
            let highBets = [];
            let validBetsCount = 0;

            // Variáveis para a funcionalidade de combinação específica
            let specificPossibleNumbers = [];
            let specificGeneratedBets = [];
            let currentPage = 1;
            const itemsPerPage = 12;
            
            // Variáveis para armazenar combinações não sorteadas
            let undrawnCombinations = [];
            
            // Variáveis para armazenar combinações sorteadas e suas frequências
            let drawnCombinations = {};
            
            // Variáveis para estatísticas de categorias de dezenas
            let numberCategoryStats = {
                low: { count: 0, percentage: 0 },
                medium: { count: 0, percentage: 0 },
                high: { count: 0, percentage: 0 },
                total: 0
            };
            
            // Variáveis para estatísticas de dezenas individuais
            let numberFrequency = {};
            
            // Variáveis para estatísticas de meses da sorte
            let monthFrequency = {
                'Jan': 0, 'Fev': 0, 'Mar': 0, 'Abr': 0, 'Mai': 0, 'Jun': 0,
                'Jul': 0, 'Ago': 0, 'Set': 0, 'Out': 0, 'Nov': 0, 'Dez': 0
            };
            
            // Variáveis para estatísticas de padrões de dígitos
            let startDigitFrequency = {};  // Para dígitos iniciais
            let endDigitFrequency = {};    // Para dígitos finais
            let patternFrequency = [];     // Para padrões completos
            
            // Variável para armazenar palpites gerados a partir de padrões selecionados
            let selectedPatternBets = [];
            
            // Mapeamento de abreviação para nome completo do mês
            const monthNameMap = {
                'Jan': 'Janeiro',
                'Fev': 'Fevereiro',
                'Mar': 'Março',
                'Abr': 'Abril',
                'Mai': 'Maio',
                'Jun': 'Junho',
                'Jul': 'Julho',
                'Ago': 'Agosto',
                'Set': 'Setembro',
                'Out': 'Outubro',
                'Nov': 'Novembro',
                'Dez': 'Dezembro'
            };
            
            // Mapeamento inverso: nome completo para abreviação
            const monthAbbrevMap = {
                'Janeiro': 'Jan',
                'Fevereiro': 'Fev',
                'Março': 'Mar',
                'Abril': 'Abr',
                'Maio': 'Mai',
                'Junho': 'Jun',
                'Julho': 'Jul',
                'Agosto': 'Ago',
                'Setembro': 'Set',
                'Outubro': 'Out',
                'Novembro': 'Nov',
                'Dezembro': 'Dez'
            };
            
            // Inicializar frequência de números
            for (let i = 1; i <= 31; i++) {
                numberFrequency[i] = 0;
            }

            // Preencher o dropdown de combinações específicas
            const specificComboSelect = document.getElementById('specificCombination');
            function updateSpecificComboDropdown() {
                specificComboSelect.innerHTML = '';
                validDigitCombinations.forEach((combo, index) => {
                    const option = document.createElement('option');
                    option.value = combo;
                    
                    // Verificar se a combinação já foi sorteada
                    if (drawnCombinations[combo] && drawnCombinations[combo] > 0) {
                        option.textContent = `${combo} (${drawnCombinations[combo]} ${drawnCombinations[combo] === 1 ? 'vez' : 'vezes'})`;
                    } else {
                        option.textContent = `★ [Não Sorteada] ${combo}`;
                        option.style.fontWeight = 'bold';
                        option.style.color = '#1e40af';  // Cor azul mais escura
                    }
                    
                    specificComboSelect.appendChild(option);
                });
            }
            
            // Chamada inicial
            updateSpecificComboDropdown();

            // Function to generate all possible two-digit numbers from the given digits
            function generateTwoDigitNumbers(digits, maxNumber) {
                const numbers = [];
                for (let i = 0; i < digits.length; i++) {
                    for (let j = 0; j < digits.length; j++) {
                        const num = parseInt(digits[i] + digits[j]);
                        // Add number if it's within range and not already in the list
                        if (num > 0 && num <= maxNumber && !numbers.includes(num)) {
                            numbers.push(num);
                        }
                    }
                }
                return numbers.sort((a, b) => a - b);
            }

            // Function to shuffle array (Fisher-Yates algorithm)
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
            
            // Função para gerar um mês da sorte aleatório
            function getRandomMonth() {
                const months = Object.keys(monthAbbrevMap);
                return months[Math.floor(Math.random() * months.length)];
            }
            
            // Função para pegar o mês da sorte mais frequente (ou aleatório se empate)
            function getMostFrequentMonth() {
                // Se não temos dados de frequência, retornar aleatório
                if (Object.values(monthFrequency).every(v => v === 0)) {
                    return getRandomMonth();
                }
                
                // Encontrar o mês mais frequente
                let maxFreq = 0;
                let mostFrequentMonths = [];
                
                for (const [month, freq] of Object.entries(monthFrequency)) {
                    if (freq > maxFreq) {
                        maxFreq = freq;
                        mostFrequentMonths = [month];
                    } else if (freq === maxFreq) {
                        mostFrequentMonths.push(month);
                    }
                }
                
                // Se houver empate, escolher aleatoriamente entre os mais frequentes
                if (mostFrequentMonths.length > 0) {
                    const selectedAbbrev = mostFrequentMonths[Math.floor(Math.random() * mostFrequentMonths.length)];
                    
                    // Encontrar o nome completo a partir da abreviação
                    for (const [name, abbrev] of Object.entries(monthAbbrevMap)) {
                        if (abbrev === selectedAbbrev) {
                            return name;
                        }
                    }
                }
                
                // Fallback para um mês aleatório
                return getRandomMonth();
            }

            // Function to generate a balanced betting sequence with specified distribution
            function generateBalancedBettingSequence(possibleNumbers, numbersPerBet, lowCount, mediumCount, highCount) {
                if (possibleNumbers.length < numbersPerBet) {
                    return null; // Not enough numbers to form a complete bet
                }
                
                // Verify the sum of counts matches the total numbers per bet
                const totalRequested = lowCount + mediumCount + highCount;
                if (totalRequested !== numbersPerBet) {
                    console.warn(`Ajuste nos números solicitados: total ${totalRequested}, necessário ${numbersPerBet}`);
                    // Adjust counts proportionally
                    const factor = numbersPerBet / totalRequested;
                    lowCount = Math.round(lowCount * factor);
                    mediumCount = Math.round(mediumCount * factor);
                    highCount = numbersPerBet - lowCount - mediumCount;
                }
                
                // Categorize available numbers
                const lowNumbers = possibleNumbers.filter(num => num <= 10);
                const mediumNumbers = possibleNumbers.filter(num => num > 10 && num <= 20);
                const highNumbers = possibleNumbers.filter(num => num > 20);
                
                // Check if we have enough numbers in each category
                if (lowNumbers.length < lowCount || mediumNumbers.length < mediumCount || highNumbers.length < highCount) {
                    // Not enough numbers in required distribution, try to adjust
                    let deficit = 0;
                    let adjustedLowCount = Math.min(lowCount, lowNumbers.length);
                    deficit += lowCount - adjustedLowCount;
                    
                    let adjustedMediumCount = Math.min(mediumCount, mediumNumbers.length);
                    deficit += mediumCount - adjustedMediumCount;
                    
                    let adjustedHighCount = Math.min(highCount, highNumbers.length);
                    deficit += highCount - adjustedHighCount;
                    
                    // If we can't meet the deficit, return null
                    if (adjustedLowCount + adjustedMediumCount + adjustedHighCount + deficit > possibleNumbers.length) {
                        console.warn("Não é possível gerar palpite com a distribuição solicitada");
                        return null;
                    }
                    
                    // Distribute deficit among available categories
                    const remainingLow = lowNumbers.length - adjustedLowCount;
                    const remainingMedium = mediumNumbers.length - adjustedMediumCount;
                    const remainingHigh = highNumbers.length - adjustedHighCount;
                    
                    // Distribute deficit proportionally to remaining capacity
                    const totalRemaining = remainingLow + remainingMedium + remainingHigh;
                    if (totalRemaining > 0) {
                        const lowDeficit = Math.min(Math.round((remainingLow / totalRemaining) * deficit), remainingLow);
                        adjustedLowCount += lowDeficit;
                        deficit -= lowDeficit;
                        
                        const mediumDeficit = Math.min(Math.round((remainingMedium / totalRemaining) * deficit), remainingMedium);
                        adjustedMediumCount += mediumDeficit;
                        deficit -= mediumDeficit;
                        
                        // Assign any remaining deficit to high numbers
                        adjustedHighCount += deficit;
                    }
                    
                    lowCount = adjustedLowCount;
                    mediumCount = adjustedMediumCount;
                    highCount = adjustedHighCount;
                }
                
                // Shuffle each category to get random selection
                shuffleArray(lowNumbers);
                shuffleArray(mediumNumbers);
                shuffleArray(highNumbers);
                
                // Select required numbers from each category
                const selectedLow = lowNumbers.slice(0, lowCount);
                const selectedMedium = mediumNumbers.slice(0, mediumCount);
                const selectedHigh = highNumbers.slice(0, highCount);
                
                // Combine and sort for final bet
                return [...selectedLow, ...selectedMedium, ...selectedHigh].sort((a, b) => a - b);
            }
            
            // Função para gerar palpites baseados em padrões selecionados pelo usuário
            function generateBetsFromSelectedPatterns() {
                // Obter os padrões iniciais selecionados
                const selectedStartPatterns = [];
                document.querySelectorAll('#startPatternSelectors input:checked').forEach(checkbox => {
                    selectedStartPatterns.push(checkbox.value);
                });
                
                // Obter os padrões finais selecionados
                const selectedEndPatterns = [];
                document.querySelectorAll('#endPatternSelectors input:checked').forEach(checkbox => {
                    selectedEndPatterns.push(checkbox.value);
                });
                
                // Verificar se pelo menos um padrão foi selecionado
                if (selectedStartPatterns.length === 0 && selectedEndPatterns.length === 0) {
                    alert("Selecione pelo menos um padrão inicial ou final para gerar palpites.");
                    return;
                }
                
                // Número de palpites a gerar
                const betCount = parseInt(document.getElementById('patternBetCount').value) || 5;
                
                // Limpar palpites anteriores
                selectedPatternBets = [];
                
                // Número de dezenas por palpite e distribuição
                const numbersPerBet = parseInt(document.getElementById('numberPerBet').value);
                const lowRange = parseInt(document.getElementById('lowRange').value);
                const mediumRange = parseInt(document.getElementById('mediumRange').value);
                const highRange = parseInt(document.getElementById('highRange').value);
                const maxNumber = 31;
                
                // Gerar palpites
                for (let i = 0; i < betCount; i++) {
                    // Escolher aleatoriamente um padrão inicial e um final
                    // (se tiver vários selecionados)
                    const startPattern = selectedStartPatterns.length > 0 ? 
                        selectedStartPatterns[Math.floor(Math.random() * selectedStartPatterns.length)] : null;
                    
                    const endPattern = selectedEndPatterns.length > 0 ?
                        selectedEndPatterns[Math.floor(Math.random() * selectedEndPatterns.length)] : null;
                    
                    // Gerar números que seguem os padrões
                    let possibleNumbers = [];
                    
                    // Extrair contagens do padrão inicial e final
                    const startDigitCounts = {};
                    const endDigitCounts = {};
                    
                    if (startPattern) {
                        startPattern.split(' ').forEach(part => {
                            if (part.endsWith('n')) {
                                const count = parseInt(part);
                                const nextPart = startPattern.split(' ')[startPattern.split(' ').indexOf(part) + 1];
                                startDigitCounts[nextPart] = (startDigitCounts[nextPart] || 0) + count;
                            }
                        });
                    }
                    
                    if (endPattern) {
                        endPattern.split(' ').forEach(part => {
                            if (part.endsWith('n')) {
                                const count = parseInt(part);
                                const nextPart = endPattern.split(' ')[endPattern.split(' ').indexOf(part) + 1];
                                endDigitCounts[nextPart] = (endDigitCounts[nextPart] || 0) + count;
                            }
                        });
                    }
                    
                    // Se não temos padrões, usar todos os números disponíveis
                    if (Object.keys(startDigitCounts).length === 0 && Object.keys(endDigitCounts).length === 0) {
                        possibleNumbers = Array.from({length: maxNumber}, (_, i) => i + 1);
                    } else {
                        // Gerar números que seguem os padrões selecionados
                        for (let num = 1; num <= maxNumber; num++) {
                            const numStr = num.toString().padStart(2, '0');
                            const startDigit = numStr[0];
                            const endDigit = numStr[1];
                            
                            // Verificar se o número segue algum dos padrões selecionados
                            let followsStartPattern = Object.keys(startDigitCounts).length === 0 || 
                                Object.keys(startDigitCounts).includes(startDigit);
                            
                            let followsEndPattern = Object.keys(endDigitCounts).length === 0 || 
                                Object.keys(endDigitCounts).includes(endDigit);
                            
                            if (followsStartPattern && followsEndPattern) {
                                possibleNumbers.push(num);
                            }
                        }
                    }
                    
                    // Garantir que não há duplicatas
                    possibleNumbers = [...new Set(possibleNumbers)];
                    
                    // Verificar se há números suficientes
                    if (possibleNumbers.length < numbersPerBet) {
                        // Adicionar números extras aleatórios
                        const extraNeeded = numbersPerBet - possibleNumbers.length;
                        const allNumbers = Array.from({length: maxNumber}, (_, i) => i + 1);
                        const extraNumbers = allNumbers
                            .filter(num => !possibleNumbers.includes(num))
                            .sort(() => Math.random() - 0.5)
                            .slice(0, extraNeeded);
                        
                        possibleNumbers = [...possibleNumbers, ...extraNumbers];
                    }
                    
                    // Usar a função de distribuição balanceada
                    const bet = generateBalancedBettingSequence(possibleNumbers, numbersPerBet, lowRange, mediumRange, highRange);
                    
                    if (bet) {
                        // Contar dezenas por categoria
                        const lowDezenas = bet.filter(num => num <= 10).length;
                        const mediumDezenas = bet.filter(num => num > 10 && num <= 20).length;
                        const highDezenas = bet.filter(num => num > 20).length;
                        
                        // Categorizar o palpite baseado no tipo predominante
                        let category;
                        if (lowDezenas >= mediumDezenas && lowDezenas >= highDezenas) {
                            category = 'low';
                        } else if (mediumDezenas >= lowDezenas && mediumDezenas >= highDezenas) {
                            category = 'medium';
                        } else {
                            category = 'high';
                        }
                        
                        // Gerar um mês da sorte
                        const luckyMonth = getMostFrequentMonth();
                        
                        // Armazenar o palpite
                        selectedPatternBets.push({
                            index: i + 1,
                            numbers: bet.map(num => formatNumber(num)),
                            category: category,
                            startPattern: startPattern || "Qualquer",
                            endPattern: endPattern || "Qualquer",
                            luckyMonth: luckyMonth,
                            distribution: {
                                low: lowDezenas,
                                medium: mediumDezenas,
                                high: highDezenas
                            }
                        });
                    }
                }
                
                // Exibir palpites na seção de resultados
                displaySelectedPatternBets();
                
                // Habilitar botões de download
                document.getElementById('downloadPatternSimpleBtn').disabled = false;
                document.getElementById('downloadPatternDetailedBtn').disabled = false;
            }
            
            // Função para exibir os palpites gerados a partir de padrões selecionados
            function displaySelectedPatternBets() {
                const resultsContainer = document.getElementById('bettingResults');
                
                if (!resultsContainer) return;
                
                // Limpar resultados anteriores
                resultsContainer.innerHTML = '';
                
                // Atualizar contadores
                let lowCount = 0, mediumCount = 0, highCount = 0;
                
                // Exibir cada palpite
                selectedPatternBets.forEach(bet => {
                    // Categorizar e incrementar contador
                    if (bet.category === 'low') lowCount++;
                    else if (bet.category === 'medium') mediumCount++;
                    else if (bet.category === 'high') highCount++;
                    
                    // Definir classe da categoria
                    let categoryClass = '';
                    let categoryLabel = '';
                    
                    if (bet.category === 'low') {
                        categoryClass = 'border-l-4 border-green-500';
                        categoryLabel = 'Baixas';
                    } else if (bet.category === 'medium') {
                        categoryClass = 'border-l-4 border-yellow-500';
                        categoryLabel = 'Médias';
                    } else if (bet.category === 'high') {
                        categoryClass = 'border-l-4 border-red-500';
                        categoryLabel = 'Altas';
                    }
                    
                    // Criar card para o palpite
                    const card = document.createElement('div');
                    card.className = `bg-white dark:bg-gray-800 shadow rounded p-4 ${categoryClass} bet-card ${bet.category}-bet`;
                    
                    // Gerar HTML para os números
                    let numbersHTML = '';
                    bet.numbers.forEach(num => {
                        const parsedNum = parseInt(num);
                        const categoryClass = getNumberCategoryClass(parsedNum);
                        numbersHTML += `<span class="inline-block ${categoryClass} rounded-full px-3 py-1 text-sm font-semibold">${formatNumber(num)}</span>`;
                    });
                    
                    // Adicionar o mês da sorte
                    const monthAbbrev = monthAbbrevMap[bet.luckyMonth] || 'Jan';
                    
                    // Montar o HTML do card
                    card.innerHTML = `
                        <div class="font-semibold text-primary mb-2 flex justify-between items-center">
                            <span>Palpite #${bet.index}</span>
                            <span class="text-xs bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded-full">
                                ${bet.numbers.length} dezenas + mês
                            </span>
                        </div>
                        <div class="text-xs text-gray-500 dark:text-gray-400 mb-2">
                            <span class="bg-teal-100 dark:bg-teal-900 text-teal-800 dark:text-teal-200 px-2 py-1 rounded-full">
                                Início: ${bet.startPattern}
                            </span>
                            <span class="ml-1 bg-purple-100 dark:bg-purple-900 text-purple-800 dark:text-purple-200 px-2 py-1 rounded-full">
                                Final: ${bet.endPattern}
                            </span>
                        </div>
                        <div class="flex flex-wrap gap-2 mb-3">
                            ${numbersHTML}
                            <span class="inline-block month-ball ml-1">${monthAbbrev}</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <div class="text-xs text-gray-500 dark:text-gray-400">
                                <span class="text-green-600 dark:text-green-400">${bet.distribution.low} baixas</span> | 
                                <span class="text-yellow-600 dark:text-yellow-400">${bet.distribution.medium} médias</span> | 
                                <span class="text-red-600 dark:text-red-400">${bet.distribution.high} altas</span>
                            </div>
                            <span class="px-2 py-1 text-xs rounded-full ${
                                bet.category === 'low' ? 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200' : 
                                bet.category === 'medium' ? 'bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200' : 
                                'bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200'
                            }">${categoryLabel}</span>
                        </div>
                    `;
                    
                    resultsContainer.appendChild(card);
                });
                
                // Atualizar contadores na UI
                document.getElementById('lowCount').textContent = lowCount;
                document.getElementById('mediumCount').textContent = mediumCount;
                document.getElementById('highCount').textContent = highCount;
                document.getElementById('totalBetsCount').textContent = selectedPatternBets.length;
                
                // Atualizar alturas das seções expansíveis
                resultsSection.updateHeight();
                
                // Expandir automaticamente a seção de resultados
                if (document.getElementById('resultsContainer').style.maxHeight === '0px') {
                    document.getElementById('resultsHeader').click();
                }
                
                // Garantir que a aba "Todos" esteja ativa
                document.getElementById('allBetsTab').click();
            }
            
            // Função para download de palpites gerados a partir de padrões selecionados (detalhado)
            function downloadPatternDetailedBets() {
                if (selectedPatternBets.length === 0) {
                    alert('Nenhum palpite gerado. Selecione padrões e gere palpites primeiro.');
                    return;
                }
                
                let text = `PALPITES GERADOS COM PADRÕES DE DÍGITOS - DIA DE SORTE\n`;
                text += `Data de geração: ${new Date().toLocaleDateString()}\n\n`;
                text += `Total de palpites: ${selectedPatternBets.length}\n\n`;
                
                // Adicionar cada palpite com detalhes
                selectedPatternBets.forEach(bet => {
                    text += `Palpite #${bet.index}\n`;
                    text += `Padrão Inicial: ${bet.startPattern}\n`;
                    text += `Padrão Final: ${bet.endPattern}\n`;
                    text += `Números: ${bet.numbers.join(' ')} ${monthAbbrevMap[bet.luckyMonth]}\n`;
                    text += `Distribuição: ${bet.distribution.low} baixas, ${bet.distribution.medium} médias, ${bet.distribution.high} altas\n\n`;
                });
                
                // Criar e simular clique no link de download
                const blob = new Blob([text], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'palpites_padrao_detalhado.txt';
                document.body.appendChild(a);
                a.click();
                
                // Limpar
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }
            
            // Função para download de palpites gerados a partir de padrões selecionados (simples)
            function downloadPatternSimpleBets() {
                if (selectedPatternBets.length === 0) {
                    alert('Nenhum palpite gerado. Selecione padrões e gere palpites primeiro.');
                    return;
                }
                
                let text = '';
                
                // Adicionar apenas os números de cada palpite
                selectedPatternBets.forEach(bet => {
                    text += `${bet.numbers.join(' ')} ${monthAbbrevMap[bet.luckyMonth]}\n`;
                });
                
                // Criar e simular clique no link de download
                const blob = new Blob([text], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'palpites_padrao_simples.txt';
                document.body.appendChild(a);
                a.click();
                
                // Limpar
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }
            
            // Função para criar checkboxes para seleção de padrões
            function createPatternSelectors() {
                const startContainer = document.getElementById('startPatternSelectors');
                const endContainer = document.getElementById('endPatternSelectors');
                
                if (!startContainer || !endContainer) return;
                
                // Limpar contêineres
                startContainer.innerHTML = '';
                endContainer.innerHTML = '';
                
                // Ordenar os padrões por frequência
                const sortedStartPatterns = Object.entries(startDigitFrequency)
                    .sort((a, b) => b[1].count - a[1].count);
                
                const sortedEndPatterns = Object.entries(endDigitFrequency)
                    .sort((a, b) => b[1].count - a[1].count);
                
                // Criar checkboxes para padrões iniciais
                sortedStartPatterns.forEach(([pattern, data]) => {
                    const div = document.createElement('div');
                    div.className = 'pattern-checkbox';
                    
                    const percentage = (data.count / patternFrequency.length * 100).toFixed(1);
                    
                    div.innerHTML = `
                        <input type="checkbox" id="start_${pattern.replace(/\s+/g, '_')}" value="${pattern}">
                        <label for="start_${pattern.replace(/\s+/g, '_')}" class="text-white">
                            ${pattern} (${data.count}x, ${percentage}%)
                        </label>
                    `;
                    
                    startContainer.appendChild(div);
                });
                
                // Criar checkboxes para padrões finais
                sortedEndPatterns.forEach(([pattern, data]) => {
                    const div = document.createElement('div');
                    div.className = 'pattern-checkbox';
                    
                    const percentage = (data.count / patternFrequency.length * 100).toFixed(1);
                    
                    div.innerHTML = `
                        <input type="checkbox" id="end_${pattern.replace(/\s+/g, '_')}" value="${pattern}">
                        <label for="end_${pattern.replace(/\s+/g, '_')}" class="text-white">
                            ${pattern} (${data.count}x, ${percentage}%)
                        </label>
                    `;
                    
                    endContainer.appendChild(div);
                });
            }
            
            // Função para gerar palpites baseados nos padrões frequentes detectados
            function generateBetsFromPatterns() {
                // Pegar os 3 padrões mais frequentes
                const topPatterns = patternFrequency
                    .sort((a, b) => b.frequency - a.frequency)
                    .slice(0, 3);
                
                if (topPatterns.length === 0) {
                    alert("Nenhum padrão frequente encontrado. Faça a análise de frequência primeiro.");
                    return;
                }
                
                // Limpar palpites anteriores
                allGeneratedBets = [];
                lowBets = [];
                mediumBets = [];
                highBets = [];
                validBetsCount = 0;
                
                const resultsContainer = document.getElementById('bettingResults');
                resultsContainer.innerHTML = '';
                
                // Número de palpites por padrão
                const palpitesPorPadrao = 4;
                const numbersPerBet = parseInt(document.getElementById('numberPerBet').value);
                const maxNumber = 31;
                
                // Para cada padrão frequente
                topPatterns.forEach((pattern, patternIndex) => {
                    for (let i = 0; i < palpitesPorPadrao; i++) {
                        // Criar palpite seguindo o padrão
                        let palpite = [];
                        let startDigitPattern = pattern.startDigitPattern;
                        let endDigitPattern = pattern.endDigitPattern;
                        
                        // Converter o padrão em contagens de dígitos
                        const startDigitCounts = {};
                        const endDigitCounts = {};
                        
                        // Extrair contagens do padrão inicial (ex: "3n 0" => 3 números começando com 0)
                        startDigitPattern.split(' ').forEach(part => {
                            if (part.endsWith('n')) {
                                const count = parseInt(part);
                                const nextPart = startDigitPattern.split(' ')[startDigitPattern.split(' ').indexOf(part) + 1];
                                startDigitCounts[nextPart] = (startDigitCounts[nextPart] || 0) + count;
                            }
                        });
                        
                        // Extrair contagens do padrão final (ex: "2n 1" => 2 números terminando em 1)
                        endDigitPattern.split(' ').forEach(part => {
                            if (part.endsWith('n')) {
                                const count = parseInt(part);
                                const nextPart = endDigitPattern.split(' ')[endDigitPattern.split(' ').indexOf(part) + 1];
                                endDigitCounts[nextPart] = (endDigitCounts[nextPart] || 0) + count;
                            }
                        });
                        
                        // Gerar números que seguem os padrões
                        let possibleNumbers = [];
                        
                        // Para cada dígito inicial
                        for (const [startDigit, count] of Object.entries(startDigitCounts)) {
                            // Para cada dígito final
                            for (const [endDigit, endCount] of Object.entries(endDigitCounts)) {
                                // Gerar todos os números possíveis com este dígito inicial e final
                                for (let num = 1; num <= maxNumber; num++) {
                                    const numStr = num.toString().padStart(2, '0');
                                    if (numStr[0] === startDigit && numStr[1] === endDigit) {
                                        possibleNumbers.push(num);
                                    }
                                }
                            }
                        }
                        
                        // Verificar se há números suficientes
                        if (possibleNumbers.length < numbersPerBet) {
                            // Adicionar números extras aleatórios
                            const extraNeeded = numbersPerBet - possibleNumbers.length;
                            const allNumbers = Array.from({length: maxNumber}, (_, i) => i + 1);
                            const extraNumbers = allNumbers
                                .filter(num => !possibleNumbers.includes(num))
                                .sort(() => Math.random() - 0.5)
                                .slice(0, extraNeeded);
                            
                            possibleNumbers = [...possibleNumbers, ...extraNumbers];
                        }
                        
                        // Garantir que não há duplicatas
                        possibleNumbers = [...new Set(possibleNumbers)];
                        
                        // Usar a função de distribuição balanceada
                        const lowRange = parseInt(document.getElementById('lowRange').value);
                        const mediumRange = parseInt(document.getElementById('mediumRange').value);
                        const highRange = parseInt(document.getElementById('highRange').value);
                        
                        const bet = generateBalancedBettingSequence(possibleNumbers, numbersPerBet, lowRange, mediumRange, highRange);
                        
                        if (bet) {
                            validBetsCount++;
                            
                            // Count dezenas por categoria
                            const lowDezenas = bet.filter(num => num <= 10).length;
                            const mediumDezenas = bet.filter(num => num > 10 && num <= 20).length;
                            const highDezenas = bet.filter(num => num > 20).length;
                            
                            // Categorize the bet based on predominant type
                            let category;
                            if (lowDezenas >= mediumDezenas && lowDezenas >= highDezenas) {
                                category = 'low';
                                lowCount++;
                            } else if (mediumDezenas >= lowDezenas && mediumDezenas >= highDezenas) {
                                category = 'medium';
                                mediumCount++;
                            } else {
                                category = 'high';
                                highCount++;
                            }
                            
                            // Gerar um mês da sorte para o palpite
                            const luckyMonth = getMostFrequentMonth();
                            
                            // Store the bet in the appropriate array
                            const betInfo = {
                                index: patternIndex * palpitesPorPadrao + i + 1,
                                combination: `Padrão #${patternIndex + 1}`,
                                numbers: bet.map(num => formatNumber(num)),
                                category: category,
                                possibleCount: possibleNumbers.length,
                                luckyMonth: luckyMonth,
                                distribution: {
                                    low: lowDezenas,
                                    medium: mediumDezenas,
                                    high: highDezenas
                                },
                                pattern: pattern
                            };
                            
                            allGeneratedBets.push(betInfo);
                            
                            if (category === 'low') lowBets.push(betInfo);
                            else if (category === 'medium') mediumBets.push(betInfo);
                            else if (category === 'high') highBets.push(betInfo);
                            
                            // Set category class
                            let categoryClass = '';
                            let categoryLabel = '';
                            
                            if (category === 'low') {
                                categoryClass = 'border-l-4 border-green-500';
                                categoryLabel = 'Baixas';
                            } else if (category === 'medium') {
                                categoryClass = 'border-l-4 border-yellow-500';
                                categoryLabel = 'Médias';
                            } else if (category === 'high') {
                                categoryClass = 'border-l-4 border-red-500';
                                categoryLabel = 'Altas';
                            }
                            
                            const card = document.createElement('div');
                            card.className = `bg-white dark:bg-gray-800 shadow rounded p-4 ${categoryClass} bet-card ${category}-bet`;
                            
                            let numbersHTML = '';
                            bet.forEach(num => {
                                const categoryClass = getNumberCategoryClass(num);
                                numbersHTML += `<span class="inline-block ${categoryClass} rounded-full px-3 py-1 text-sm font-semibold">${formatNumber(num)}</span>`;
                            });
                            
                            // Adicionar o mês da sorte
                            const monthAbbrev = monthAbbrevMap[luckyMonth] || 'Jan';
                            
                            card.innerHTML = `
                                <div class="font-semibold text-primary mb-2 flex justify-between items-center">
                                    <span>Palpite do Padrão #${patternIndex + 1}</span>
                                    <span class="text-xs bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded-full">
                                        ${numbersPerBet} dezenas + mês
                                    </span>
                                </div>
                                <div class="text-xs text-gray-500 dark:text-gray-400 mb-2">
                                    <span class="bg-teal-100 dark:bg-teal-900 text-teal-800 dark:text-teal-200 px-2 py-1 rounded-full">
                                        Início: ${pattern.startDigitPattern}
                                    </span>
                                    <span class="ml-1 bg-purple-100 dark:bg-purple-900 text-purple-800 dark:text-purple-200 px-2 py-1 rounded-full">
                                        Final: ${pattern.endDigitPattern}
                                    </span>
                                </div>
                                <div class="flex flex-wrap gap-2 mb-3">
                                    ${numbersHTML}
                                    <span class="inline-block month-ball ml-1">${monthAbbrev}</span>
                                </div>
                                <div class="flex justify-between items-center">
                                    <div class="text-xs text-gray-500 dark:text-gray-400">
                                        <span class="text-green-600 dark:text-green-400">${lowDezenas} baixas</span> | 
                                        <span class="text-yellow-600 dark:text-yellow-400">${mediumDezenas} médias</span> | 
                                        <span class="text-red-600 dark:text-red-400">${highDezenas} altas</span>
                                    </div>
                                    <span class="px-2 py-1 text-xs rounded-full ${
                                        category === 'low' ? 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200' : 
                                        category === 'medium' ? 'bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200' : 
                                        'bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200'
                                    }">${categoryLabel}</span>
                                </div>
                            `;
                            resultsContainer.appendChild(card);
                        }
                    }
                });
                
                // Update counters in the UI
                document.getElementById('lowCount').textContent = lowCount;
                document.getElementById('mediumCount').textContent = mediumCount;
                document.getElementById('highCount').textContent = highCount;
                document.getElementById('totalBetsCount').textContent = validBetsCount;
                
                // Atualizar alturas das seções expansíveis após preencher o conteúdo
                resultsSection.updateHeight();
                
                // Expandir automaticamente a seção de resultados após gerar
                if (document.getElementById('resultsContainer').style.maxHeight === '0px') {
                    document.getElementById('resultsHeader').click();
                }
                
                // Exibir todos os palpites (garantindo que a aba "Todos" esteja ativa)
                document.getElementById('allBetsTab').click();
				
				// Armazenar os palpites gerados para uso no misturador
				patternGeneratedBets = [...allGeneratedBets];
            }

            // Function to format a number with leading zero if needed
            function formatNumber(num) {
                return num < 10 ? '0' + num : num.toString();
            }

            // Function to get number category class
            function getNumberCategoryClass(num) {
                if (num <= 10) return 'number-low';
                if (num <= 20) return 'number-medium';
                return 'number-high';
            }

            // Function to generate and display the results
            function generateResults() {
                // Nota: maxNumber é fixo em 31 agora
                const maxNumber = 31; // parseInt(document.getElementById('maxNumber').value);
                const numbersPerBet = parseInt(document.getElementById('numberPerBet').value);
                const lowRange = parseInt(document.getElementById('lowRange').value);
                const mediumRange = parseInt(document.getElementById('mediumRange').value);
                const highRange = parseInt(document.getElementById('highRange').value);
                
                const resultsContainer = document.getElementById('bettingResults');
                const tableBody = document.getElementById('combinationsTableBody');
                const statisticsContent = document.getElementById('statisticsContent');
                const statisticsTotal = document.getElementById('statisticsTotal');
                
                resultsContainer.innerHTML = '';
                tableBody.innerHTML = '';
                statisticsContent.innerHTML = '';
                
                // Reset the bet arrays and counter
                allGeneratedBets = [];
                lowBets = [];
                mediumBets = [];
                highBets = [];
                validBetsCount = 0;
                
                // Object to count how many combinations generate each number of possibilities
                const stats = {};
                let totalCombinations = 0;
                let lowCount = 0, mediumCount = 0, highCount = 0;
                
                validDigitCombinations.forEach((combination, index) => {
                    const digits = combination.split(',');
                    const possibleNumbers = generateTwoDigitNumbers(digits, maxNumber);
                    const count = possibleNumbers.length;
                    
                    // Update statistics
                    stats[count] = (stats[count] || 0) + 1;
                    totalCombinations++;
                    
                    // Add to combinations table
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td class="px-2 py-2">${combination}</td>
                        <td class="px-2 py-2">${possibleNumbers.map(formatNumber).join(' ')}</td>
                        <td class="px-2 py-2">${count}</td>
                    `;
                    tableBody.appendChild(row);

                    // Create balanced betting sequence
                    const bet = generateBalancedBettingSequence(possibleNumbers, numbersPerBet, lowRange, mediumRange, highRange);
                    
                    if (bet) {
                        validBetsCount++;
                        
                        // Count dezenas por categoria
                        const lowDezenas = bet.filter(num => num <= 10).length;
                        const mediumDezenas = bet.filter(num => num > 10 && num <= 20).length;
                        const highDezenas = bet.filter(num => num > 20).length;
                        
                        // Categorize the bet based on predominant type
                        let category;
                        if (lowDezenas >= mediumDezenas && lowDezenas >= highDezenas) {
                            category = 'low';
                            lowCount++;
                        } else if (mediumDezenas >= lowDezenas && mediumDezenas >= highDezenas) {
                            category = 'medium';
                            mediumCount++;
                        } else {
                            category = 'high';
                            highCount++;
                        }
                        
                        // Gerar um mês da sorte para o palpite
                        // Usar o mês mais frequente ou aleatório se não houver dados
                        const luckyMonth = getMostFrequentMonth();
                        
                        // Store the bet in the appropriate array
                        const betInfo = {
                            index: index + 1,
                            combination: combination,
                            numbers: bet.map(num => formatNumber(num)),
                            category: category,
                            possibleCount: count,
                            luckyMonth: luckyMonth,
                            distribution: {
                                low: lowDezenas,
                                medium: mediumDezenas,
                                high: highDezenas
                            }
                        };
                        
                        allGeneratedBets.push(betInfo);
                        
                        if (category === 'low') lowBets.push(betInfo);
                        else if (category === 'medium') mediumBets.push(betInfo);
                        else if (category === 'high') highBets.push(betInfo);
                        
                        // Set category class
                        let categoryClass = '';
                        let categoryLabel = '';
                        
                        if (category === 'low') {
                            categoryClass = 'border-l-4 border-green-500';
                            categoryLabel = 'Baixas';
                        } else if (category === 'medium') {
                            categoryClass = 'border-l-4 border-yellow-500';
                            categoryLabel = 'Médias';
                        } else if (category === 'high') {
                            categoryClass = 'border-l-4 border-red-500';
                            categoryLabel = 'Altas';
                        }
                        
                        const card = document.createElement('div');
                        card.className = `bg-white dark:bg-gray-800 shadow rounded p-4 ${categoryClass} bet-card` + 
                                       ` ${category}-bet`; // Add class for filtering
                        
                        let numbersHTML = '';
                        bet.forEach(num => {
                            const categoryClass = getNumberCategoryClass(num);
                            numbersHTML += `<span class="inline-block ${categoryClass} rounded-full px-3 py-1 text-sm font-semibold">${formatNumber(num)}</span>`;
                        });
                        
                        // Adicionar o mês da sorte
                        const monthAbbrev = monthAbbrevMap[luckyMonth] || 'Jan';
                        
                        card.innerHTML = `
                            <div class="font-semibold text-primary mb-2 flex justify-between items-center">
                                <span>Palpite #${index + 1}</span>
                                <span class="text-xs bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded-full">
                                    ${numbersPerBet} dezenas + mês
                                </span>
                            </div>
                            <div class="text-xs text-gray-500 dark:text-gray-400 mb-2">Dígitos: ${combination}</div>
                            <div class="flex flex-wrap gap-2 mb-3">
                                ${numbersHTML}
                                <span class="inline-block month-ball ml-1">${monthAbbrev}</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <div class="text-xs text-gray-500 dark:text-gray-400">
                                    <span class="text-green-600 dark:text-green-400">${lowDezenas} baixas</span> | 
                                    <span class="text-yellow-600 dark:text-yellow-400">${mediumDezenas} médias</span> | 
                                    <span class="text-red-600 dark:text-red-400">${highDezenas} altas</span>
                                </div>
                                <span class="px-2 py-1 text-xs rounded-full ${
                                    category === 'low' ? 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200' : 
                                    category === 'medium' ? 'bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200' : 
                                    'bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200'
                                }">${categoryLabel}</span>
                            </div>
                        `;
                        resultsContainer.appendChild(card);
                    } else {
                        const card = document.createElement('div');
                        card.className = 'bg-white dark:bg-gray-800 shadow rounded p-4';
                        card.innerHTML = `
                            <div class="font-semibold text-red-500 mb-2">Palpite #${index + 1} - Dígitos: ${combination}</div>
                            <div class="text-sm text-red-400">Não há números suficientes para formar um palpite equilibrado.</div>
                            <div class="text-xs text-gray-500 dark:text-gray-400">Total de números possíveis: ${count}</div>
                        `;
                        resultsContainer.appendChild(card);
                    }
                });
                
                // Update counters in the UI
                document.getElementById('lowCount').textContent = lowCount;
                document.getElementById('mediumCount').textContent = mediumCount;
                document.getElementById('highCount').textContent = highCount;
                document.getElementById('totalBetsCount').textContent = validBetsCount;
                
                // Generate statistics summary
                const sortedCounts = Object.keys(stats).sort((a, b) => parseInt(a) - parseInt(b));
                
                sortedCounts.forEach(count => {
                    const statItem = document.createElement('div');
                    statItem.className = 'bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded p-3';
                    statItem.innerHTML = `
                        <div class="font-semibold"><span class="font-bold text-primary">${stats[count]}</span> conjuntos de dígitos geram <span class="font-bold text-primary">${count}</span> números</div>
                        <div class="text-sm mt-1">${stats[count] === 1 ? 'Representa' : 'Representam'} ${((stats[count] / totalCombinations) * 100).toFixed(1)}% do total</div>
                    `;
                    statisticsContent.appendChild(statItem);
                });
                
                // Add total
                statisticsTotal.innerHTML = `Total: ${totalCombinations} conjuntos de dígitos analisados`;
                
                // Atualizar alturas das seções expansíveis após preencher o conteúdo
                combinationsSection.updateHeight();
                statsSection.updateHeight();
                resultsSection.updateHeight();
                
                // Expandir automaticamente a seção de resultados após gerar
                if (document.getElementById('resultsContainer').style.maxHeight === '0px') {
                    document.getElementById('resultsHeader').click();
                }
            }

            // Função para gerar texto para download
            function generateDownloadText() {
                const maxNumber = 31; // Fixed at 31
                const numbersPerBet = parseInt(document.getElementById('numberPerBet').value);
                const lowRange = parseInt(document.getElementById('lowRange').value);
                const mediumRange = parseInt(document.getElementById('mediumRange').value);
                const highRange = parseInt(document.getElementById('highRange').value);
                
                let text = `PALPITES GERADOS - DIA DE SORTE\n`;
                text += `Números por palpite: ${numbersPerBet} | Número máximo: ${maxNumber}\n`;
                text += `Distribuição pretendida: ${lowRange} baixas, ${mediumRange} médias, ${highRange} altas\n`;
                text += `Data de geração: ${new Date().toLocaleDateString()}\n\n`;
                
                // Adicionar estatísticas
                text += `RESUMO DOS PALPITES:\n`;
                text += `Total de palpites gerados: ${validBetsCount}\n`;
                text += `Palpites com predominância de dezenas baixas (1-10): ${document.getElementById('lowCount').textContent}\n`;
                text += `Palpites com predominância de dezenas médias (11-20): ${document.getElementById('mediumCount').textContent}\n`;
                text += `Palpites com predominância de dezenas altas (21-31): ${document.getElementById('highCount').textContent}\n\n`;
                
                // Adicionar palpites por categoria
                text += `=== PALPITES COM PREDOMINÂNCIA DE DEZENAS BAIXAS (1-10) ===\n\n`;
                lowBets.forEach(bet => {
                    text += `Palpite #${bet.index} - Dígitos: ${bet.combination}\n`;
                    text += `Números: ${bet.numbers.join(' ')} ${monthAbbrevMap[bet.luckyMonth]}\n`;
                    text += `Distribuição: ${bet.distribution.low} baixas, ${bet.distribution.medium} médias, ${bet.distribution.high} altas\n\n`;
                });
                
                text += `=== PALPITES COM PREDOMINÂNCIA DE DEZENAS MÉDIAS (11-20) ===\n\n`;
                mediumBets.forEach(bet => {
                    text += `Palpite #${bet.index} - Dígitos: ${bet.combination}\n`;
                    text += `Números: ${bet.numbers.join(' ')} ${monthAbbrevMap[bet.luckyMonth]}\n`;
                    text += `Distribuição: ${bet.distribution.low} baixas, ${bet.distribution.medium} médias, ${bet.distribution.high} altas\n\n`;
                });
                
                text += `=== PALPITES COM PREDOMINÂNCIA DE DEZENAS ALTAS (21-31) ===\n\n`;
                highBets.forEach(bet => {
                    text += `Palpite #${bet.index} - Dígitos: ${bet.combination}\n`;
                    text += `Números: ${bet.numbers.join(' ')} ${monthAbbrevMap[bet.luckyMonth]}\n`;
                    text += `Distribuição: ${bet.distribution.low} baixas, ${bet.distribution.medium} médias, ${bet.distribution.high} altas\n\n`;
                });
                
                return text;
            }

            // Função para gerar texto simples para download (apenas os números)
            function generateSimpleDownloadText() {
                let text = '';
                
                // Apenas os números de cada palpite, separados por espaço
                allGeneratedBets.forEach(bet => {
                    text += `${bet.numbers.join(' ')} ${monthAbbrevMap[bet.luckyMonth]}\n`;
                });
                
                return text;
            }
            
            // Função para gerar texto de download das combinações não sorteadas
            function generateUndrawnCombinationsText() {
                let text = `COMBINAÇÕES AINDA NÃO SORTEADAS - DIA DE SORTE\n`;
                text += `Data de extração: ${new Date().toLocaleDateString()}\n\n`;
                text += `Total de combinações não sorteadas: ${undrawnCombinations.length} de ${validDigitCombinations.length}\n\n`;
                
                text += undrawnCombinations.join('\n');
                
                return text;
            }
            
            // Função para download de combinações não sorteadas
            function downloadUndrawnCombinations() {
                if (undrawnCombinations.length === 0) {
                    alert('Não há combinações não sorteadas para baixar ou a análise ainda não foi realizada.');
                    return;
                }
                
                const textContent = generateUndrawnCombinationsText();
                const blob = new Blob([textContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                // Criar um link temporário e simular clique
                const a = document.createElement('a');
                a.href = url;
                a.download = 'combinacoes_nao_sorteadas.txt';
                document.body.appendChild(a);
                a.click();
                
                // Limpar
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }
			// Função para verificar quando foi a última atualização do cache
			function getLastCacheUpdateInfo() {
				try {
					const cacheInfo = localStorage.getItem('dia_de_sorte_cache_info');
					if (!cacheInfo) return null;
					
					const info = JSON.parse(cacheInfo);
					const lastUpdate = new Date(info.timestamp);
					const now = new Date();
					
					// Calcular tempo decorrido
					const diffMs = now - lastUpdate;
					const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
					const diffHours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
					const diffMinutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
					
					let timeText = '';
					if (diffDays > 0) {
						timeText += `${diffDays} dia${diffDays > 1 ? 's' : ''}`;
					}
					if (diffHours > 0) {
						if (timeText) timeText += ', ';
						timeText += `${diffHours} hora${diffHours > 1 ? 's' : ''}`;
					}
					if (diffMinutes > 0 && diffDays === 0) { // Mostrar minutos apenas se não tiver passado mais de um dia
						if (timeText) timeText += ' e ';
						timeText += `${diffMinutes} minuto${diffMinutes > 1 ? 's' : ''}`;
					}
					
					return {
						lastConcurso: info.lastConcurso,
						countConcursos: info.countConcursos,
						timeAgo: timeText || 'agora mesmo',
						timestamp: info.timestamp
					};
				} catch (error) {
					console.error('Erro ao obter informações de cache:', error);
					return null;
				}
			}

			// Função para atualizar informações sobre o cache
			function updateCacheInfo(lastConcurso, countConcursos) {
				try {
					const cacheInfo = {
						lastConcurso: lastConcurso,
						countConcursos: countConcursos,
						timestamp: new Date().toISOString()
					};
					localStorage.setItem('dia_de_sorte_cache_info', JSON.stringify(cacheInfo));
					return true;
				} catch (error) {
					console.error('Erro ao atualizar informações de cache:', error);
					return false;
				}
			}

			// Função para atualizar as informações do botão de cache
			function updateCacheButton() {
				const cacheInfo = getLastCacheUpdateInfo();
				const cacheInfoElement = document.getElementById('cacheInfo');
				
				if (cacheInfoElement) {
					if (cacheInfo) {
						cacheInfoElement.textContent = `Atualizado há ${cacheInfo.timeAgo}`;
					} else {
						cacheInfoElement.textContent = 'Nunca atualizado';
					}
				}
			}
			// Função para buscar o último concurso
			async function fetchLatestConcurso() {
				try {
					const url = API_CONFIG.CAIXA_URL;
					const data = await fetchViaProxy(url, {
						'Origin': 'https://loterias.caixa.gov.br',
						'Referer': 'https://loterias.caixa.gov.br/'
					});
					
					if (!data || !data.numero) {
						throw new Error("Dados do concurso inválidos");
					}
					
					return data;
				} catch (error) {
					console.error("Erro ao buscar último concurso:", error);
					return null;
				}
			}

			// Função para buscar um concurso específico
			async function fetchConcursoData(concursoNum) {
				try {
					const url = `${API_CONFIG.CAIXA_URL}/${concursoNum}`;
					
					const data = await fetchViaProxy(url, {
						'Origin': 'https://loterias.caixa.gov.br',
						'Referer': 'https://loterias.caixa.gov.br/'
					});
					
					if (!data || !data.numero) {
						throw new Error("Dados do concurso inválidos");
					}
					
					return data;
				} catch (error) {
					console.error(`Erro ao buscar concurso ${concursoNum}:`, error);
					return null;
				}
			}

			// Função para formatar os dados do concurso
				// Função para formatar os dados do concurso
				function formatConcursoData(data) {
					if (!data || !data.listaDezenas || !Array.isArray(data.listaDezenas)) {
						return null;
					}
					
					let resultLine = data.listaDezenas.join(' ');
					
					// Adicionar o mês da sorte se disponível
					// A API da Caixa usa o campo "nomeTimeCoracaoMesSorte" para o mês da sorte
					if (data.nomeTimeCoracaoMesSorte) {
						// Tenta obter a abreviação correta do mês
						for (const [abbrev, name] of Object.entries(monthNameMap)) {
							if (name.toLowerCase() === data.nomeTimeCoracaoMesSorte.toLowerCase()) {
								resultLine += ' ' + abbrev;
								break;
							}
						}
					} else if (data.nomeMesDaSorte) {
						// Caso alternativo, se o nome do campo mudar
						for (const [abbrev, name] of Object.entries(monthNameMap)) {
							if (name.toLowerCase() === data.nomeMesDaSorte.toLowerCase()) {
								resultLine += ' ' + abbrev;
								break;
							}
						}
					}
					
					return resultLine;
				}			
			
			
			
			
			
            // Função para download dos palpites detalhados
            function downloadBets() {
                if (allGeneratedBets.length === 0) {
                    alert('Gere os palpites primeiro antes de baixar.');
                    return;
                }
                
                const textContent = generateDownloadText();
                const blob = new Blob([textContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                // Criar um link temporário e simular clique
                const a = document.createElement('a');
                a.href = url;
                a.download = 'palpites_dia_de_sorte.txt';
                document.body.appendChild(a);
                a.click();
                
                // Limpar
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }

            // Função para download dos palpites simplificados (apenas os números)
            function downloadSimpleBets() {
                if (allGeneratedBets.length === 0) {
                    alert('Gere os palpites primeiro antes de baixar.');
                    return;
                }
                
                const textContent = generateSimpleDownloadText();
                const blob = new Blob([textContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                // Criar um link temporário e simular clique
                const a = document.createElement('a');
                a.href = url;
                a.download = 'palpites_simples.txt';
                document.body.appendChild(a);
                a.click();
                
                // Limpar
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }

            // Função para configurar paginação dos resultados específicos
            function setupPagination() {
                const totalPages = Math.ceil(specificGeneratedBets.length / itemsPerPage);
                const paginationInfo = document.getElementById('paginationInfo');
                const prevBtn = document.getElementById('prevPageBtn');
                const nextBtn = document.getElementById('nextPageBtn');
                
                // Atualizar informações de página
                paginationInfo.textContent = `Página ${currentPage} de ${totalPages || 1}`;
                
                // Habilitar/desabilitar botões
                prevBtn.disabled = currentPage <= 1;
                nextBtn.disabled = currentPage >= totalPages;
                
                // Mostrar resultados da página atual
                showSpecificBetsPage();
                
                // Atualizar altura da seção expansível
                specificSection.updateHeight();
            }

            // Função para mostrar a página atual de palpites específicos
            function showSpecificBetsPage() {
                const startIndex = (currentPage - 1) * itemsPerPage;
                const endIndex = Math.min(startIndex + itemsPerPage, specificGeneratedBets.length);
                const resultsContainer = document.getElementById('specificResultsContainer');
                
                resultsContainer.innerHTML = '';
                
                // Se não há resultados
                if (specificGeneratedBets.length === 0) {
                    resultsContainer.innerHTML = `
                        <div class="col-span-full p-4 text-center text-gray-500 dark:text-gray-400">
                            Nenhum palpite gerado. Selecione uma combinação e clique em "Gerar Palpites".
                        </div>
                    `;
                    return;
                }
                
                // Mostrar palpites da página atual
                for (let i = startIndex; i < endIndex; i++) {
                    const bet = specificGeneratedBets[i];
                    const card = document.createElement('div');
                    card.className = 'bg-white dark:bg-gray-800 shadow rounded p-4';
                    
                    let numbersHTML = '';
                    bet.numbers.forEach(num => {
                        const parsedNum = parseInt(num);
                        const categoryClass = getNumberCategoryClass(parsedNum);
                        numbersHTML += `<span class="inline-block ${categoryClass} rounded-full px-3 py-1 text-sm font-semibold">${num}</span>`;
                    });
                    
                    // Adicionar o mês da sorte
                    const monthAbbrev = monthAbbrevMap[bet.luckyMonth] || 'Jan';
                    
                    const lowCount = bet.numbers.filter(n => parseInt(n) <= 10).length;
                    const mediumCount = bet.numbers.filter(n => parseInt(n) > 10 && parseInt(n) <= 20).length;
                    const highCount = bet.numbers.filter(n => parseInt(n) > 20).length;
                    
                    card.innerHTML = `
                        <div class="font-semibold text-primary mb-2 flex justify-between">
                            <span>Palpite #${i + 1}</span>
                            <span class="text-xs bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded-full">
                                ${bet.numbers.length} dezenas + mês
                            </span>
                        </div>
                        <div class="flex flex-wrap gap-2 mb-3">
                            ${numbersHTML}
                            <span class="inline-block month-ball ml-1">${monthAbbrev}</span>
                        </div>
                        <div class="text-xs text-gray-500 dark:text-gray-400">
                            <span class="text-green-600 dark:text-green-400">${lowCount} baixas</span> | 
                            <span class="text-yellow-600 dark:text-yellow-400">${mediumCount} médias</span> | 
                            <span class="text-red-600 dark:text-red-400">${highCount} altas</span>
                        </div>
                    `;
                    resultsContainer.appendChild(card);
                }
            }

            // Função para gerar todas as combinações possíveis de K elementos em um array
            function generateCombinations(array, k) {
                const result = [];
                
                // Função recursiva para gerar combinações
                function backtrack(start, current) {
                    if (current.length === k) {
                        result.push([...current]);
                        return;
                    }
                    
                    for (let i = start; i < array.length; i++) {
                        current.push(array[i]);
                        backtrack(i + 1, current);
                        current.pop();
                    }
                }
                
                backtrack(0, []);
                return result;
            }

            // Função para mostrar os números possíveis para a combinação selecionada
            function updatePossibleNumbers() {
                const selectedCombo = document.getElementById('specificCombination').value;
                const maxNumber = 31; // Fixo em 31
                const digits = selectedCombo.split(',');
                
                specificPossibleNumbers = generateTwoDigitNumbers(digits, maxNumber);
                
                // Atualizar a contagem de dezenas possíveis
                const countElement = document.getElementById('possibleNumberCount');
                countElement.textContent = specificPossibleNumbers.length;
                
                // Atualizar a exibição dos números possíveis
                const display = document.getElementById('possibleNumbersDisplay');
                display.innerHTML = '';
                
                specificPossibleNumbers.forEach(num => {
                    const numStr = formatNumber(num);
                    const categoryClass = getNumberCategoryClass(num);
                    const span = document.createElement('span');
                    span.className = `inline-block ${categoryClass} rounded-full px-3 py-1 text-sm font-semibold`;
                    span.textContent = numStr;
                    display.appendChild(span);
                });
                
                // Limpar resultados anteriores
                specificGeneratedBets = [];
                document.getElementById('specificBetCount').textContent = '0';
                document.getElementById('specificResultsContainer').innerHTML = '';
                document.getElementById('downloadSpecificBtn').disabled = true;
                document.getElementById('downloadSpecificSimpleBtn').disabled = true;
                
                // Atualizar altura da seção expansível
                specificSection.updateHeight();
                
                setupPagination();
            }

            // Função para gerar palpites para a combinação específica
            function generateSpecificBets() {
                const numbersPerBet = parseInt(document.getElementById('specificNumberPerBet').value);
                const selectedCombo = document.getElementById('specificCombination').value;
                const lowRange = parseInt(document.getElementById('lowRange').value);
                const mediumRange = parseInt(document.getElementById('mediumRange').value);
                const highRange = parseInt(document.getElementById('highRange').value);
                
                // Verificar se há números suficientes
                if (specificPossibleNumbers.length < numbersPerBet) {
                    alert(`Esta combinação gera apenas ${specificPossibleNumbers.length} números possíveis, o que é insuficiente para formar um palpite com ${numbersPerBet} dezenas.`);
                    return;
                }
                
                // Calcular todas as combinações possíveis
                const allCombos = generateCombinations(specificPossibleNumbers, numbersPerBet);
                
                // Gerar palpites balanceados, considerando a distribuição
                specificGeneratedBets = [];
                
                allCombos.forEach(combo => {
                    // Classificar os números por categoria
                    const lowCount = combo.filter(num => num <= 10).length;
                    const mediumCount = combo.filter(num => num > 10 && num <= 20).length;
                    const highCount = combo.filter(num => num > 20).length;
                    
                    // Verificar se a distribuição está próxima da desejada
                    // Adicionamos uma tolerância para permitir variações
                    const isBalanced = Math.abs(lowCount - lowRange) <= 2 && 
                                       Math.abs(mediumCount - mediumRange) <= 2 && 
                                       Math.abs(highCount - highRange) <= 2;
                    
                    specificGeneratedBets.push({
                        numbers: combo.map(num => formatNumber(num)),
                        luckyMonth: getMostFrequentMonth(), // Adicionar mês da sorte
                        isBalanced: isBalanced
                    });
                });
                
                // Ordenar para que os palpites balanceados apareçam primeiro
                specificGeneratedBets.sort((a, b) => {
                    if (a.isBalanced && !b.isBalanced) return -1;
                    if (!a.isBalanced && b.isBalanced) return 1;
                    return 0;
                });
                
                // Atualizar contador e habilitar botões de download
                document.getElementById('specificBetCount').textContent = specificGeneratedBets.length;
                document.getElementById('downloadSpecificBtn').disabled = false;
                document.getElementById('downloadSpecificSimpleBtn').disabled = false;
                
                // Configurar paginação e mostrar resultados
                currentPage = 1;
                setupPagination();
                
                // Expandir a seção se estiver fechada
                if (document.getElementById('specificContainer').style.maxHeight === '0px') {
                    document.getElementById('specificHeader').click();
                }
            }

            // Função para gerar texto de download dos palpites específicos
            function generateSpecificDownloadText() {
                if (specificGeneratedBets.length === 0) return '';
                
                const selectedCombo = document.getElementById('specificCombination').value;
                const numbersPerBet = parseInt(document.getElementById('specificNumberPerBet').value);
                
                let text = `PALPITES GERADOS PARA COMBINAÇÃO DE DÍGITOS: ${selectedCombo}\n`;
                text += `Números por palpite: ${numbersPerBet}\n`;
                text += `Data de geração: ${new Date().toLocaleDateString()}\n\n`;
                text += `Total de palpites: ${specificGeneratedBets.length}\n\n`;
                
                // Adicionar cada palpite
                specificGeneratedBets.forEach((bet, index) => {
                    text += `Palpite #${index + 1}: ${bet.numbers.join(' ')} ${monthAbbrevMap[bet.luckyMonth]}\n`;
                });
                
                return text;
            }
            
            // Função para gerar texto simples de download dos palpites específicos
            function generateSpecificSimpleDownloadText() {
                if (specificGeneratedBets.length === 0) return '';
                
                let text = '';
                
                // Adicionar cada palpite, apenas números e mês
                specificGeneratedBets.forEach(bet => {
                    text += `${bet.numbers.join(' ')} ${monthAbbrevMap[bet.luckyMonth]}\n`;
                });
                
                return text;
            }

            // Função para download dos palpites específicos detalhados
            function downloadSpecificBets() {
                if (specificGeneratedBets.length === 0) {
                    alert('Nenhum palpite foi gerado para download.');
                    return;
                }
                
                const textContent = generateSpecificDownloadText();
                const blob = new Blob([textContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                // Criar um link temporário e simular clique
                const a = document.createElement('a');
                a.href = url;
                a.download = 'palpites_específicos.txt';
                document.body.appendChild(a);
                a.click();
                
                // Limpar
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }
            
            // Função para download dos palpites específicos simplificados
            function downloadSpecificSimpleBets() {
                if (specificGeneratedBets.length === 0) {
                    alert('Nenhum palpite foi gerado para download.');
                    return;
                }
                
                const textContent = generateSpecificSimpleDownloadText();
                const blob = new Blob([textContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                // Criar um link temporário e simular clique
                const a = document.createElement('a');
                a.href = url;
                a.download = 'palpites_específicos_simples.txt';
                document.body.appendChild(a);
                a.click();
                
                // Limpar
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }

            // Configurar abas para filtrar os palpites
            function setupTabs() {
                const allTab = document.getElementById('allBetsTab');
                const lowTab = document.getElementById('lowBetsTab');
                const mediumTab = document.getElementById('mediumBetsTab');
                const highTab = document.getElementById('highBetsTab');
                
                // Função para atualizar a aparência das abas
                function updateTabAppearance(activeTab) {
                    // Remover estilos ativos de todas as abas
                    [allTab, lowTab, mediumTab, highTab].forEach(tab => {
                        tab.classList.remove('border-b-2', 'border-primary', 'text-primary');
                        tab.classList.add('text-gray-600', 'dark:text-gray-400');
                    });
                    
                    // Adicionar estilos à aba ativa
                    activeTab.classList.remove('text-gray-600', 'dark:text-gray-400');
                    activeTab.classList.add('border-b-2', 'border-primary', 'text-primary');
                }
                
                // Função para forçar a atualização da altura da seção de resultados
                function forceUpdateHeight() {
                    console.log("Forçando atualização da altura da seção de resultados");
                    setTimeout(() => {
                        const resultsContainer = document.getElementById('resultsContainer');
                        if (resultsContainer && resultsContainer.style.maxHeight !== '0px') {
                            resultsContainer.style.maxHeight = '5000px';
                        }
                    }, 50);
                }
                
                // Configurar manipuladores de eventos
                allTab.addEventListener('click', function() {
                    document.querySelectorAll('.bet-card').forEach(card => {
                        card.style.display = 'block';
                    });
                    updateTabAppearance(allTab);
                    forceUpdateHeight();
                });
                
                lowTab.addEventListener('click', function() {
                    document.querySelectorAll('.bet-card').forEach(card => {
                        if (card.classList.contains('low-bet')) {
                            card.style.display = 'block';
                        } else {
                            card.style.display = 'none';
                        }
                    });
                    updateTabAppearance(lowTab);
                    forceUpdateHeight();
                });
                
                mediumTab.addEventListener('click', function() {
                    document.querySelectorAll('.bet-card').forEach(card => {
                        if (card.classList.contains('medium-bet')) {
                            card.style.display = 'block';
                        } else {
                            card.style.display = 'none';
                        }
                    });
                    updateTabAppearance(mediumTab);
                    forceUpdateHeight();
                });
                
                highTab.addEventListener('click', function() {
                    document.querySelectorAll('.bet-card').forEach(card => {
                        if (card.classList.contains('high-bet')) {
                            card.style.display = 'block';
                        } else {
                            card.style.display = 'none';
                        }
                    });
                    updateTabAppearance(highTab);
                    forceUpdateHeight();
                });
            }
            
            // Função para renderizar o gráfico de barras da estatística de dezenas
            function renderNumberCategoryChart() {
                // Calcula as percentagens para o gráfico
                const total = numberCategoryStats.total;
                if (total === 0) return;
                
                // Atualizar percentagens
                numberCategoryStats.low.percentage = (numberCategoryStats.low.count / total) * 100;
                numberCategoryStats.medium.percentage = (numberCategoryStats.medium.count / total) * 100;
                numberCategoryStats.high.percentage = (numberCategoryStats.high.count / total) * 100;
                
                // Renderizar as barras diretamente
                const lowBar = document.getElementById('lowBar');
                const mediumBar = document.getElementById('mediumBar');
                const highBar = document.getElementById('highBar');
                
                if (lowBar && mediumBar && highBar) {
                    // Definir as alturas e textos das barras
                    lowBar.style.height = `${Math.max(10, numberCategoryStats.low.percentage)}%`;
                    lowBar.textContent = `${Math.round(numberCategoryStats.low.percentage)}%`;
                    
                    mediumBar.style.height = `${Math.max(10, numberCategoryStats.medium.percentage)}%`;
                    mediumBar.textContent = `${Math.round(numberCategoryStats.medium.percentage)}%`;
                    
                    highBar.style.height = `${Math.max(10, numberCategoryStats.high.percentage)}%`;
                    highBar.textContent = `${Math.round(numberCategoryStats.high.percentage)}%`;
                    
                    // Atualizar rótulos abaixo das barras
                    lowBar.nextElementSibling.innerHTML = `${numberCategoryStats.low.count} dezenas<br>baixas`;
                    mediumBar.nextElementSibling.innerHTML = `${numberCategoryStats.medium.count} dezenas<br>Médias`;
                    highBar.nextElementSibling.innerHTML = `${numberCategoryStats.high.count} dezenas<br>Altas`;
                }
                
                // Atualiza os detalhes numéricos
                document.getElementById('lowNumberStats').innerHTML = `
                    <div><strong>${numberCategoryStats.low.count}</strong> dezenas (${numberCategoryStats.low.percentage.toFixed(1)}%)</div>
                    <div class="text-sm italic">1, 2, 3, 4, 5, 6, 7, 8, 9, 10</div>
                `;
                document.getElementById('mediumNumberStats').innerHTML = `
                    <div><strong>${numberCategoryStats.medium.count}</strong> dezenas (${numberCategoryStats.medium.percentage.toFixed(1)}%)</div>
                    <div class="text-sm italic">11, 12, 13, 14, 15, 16, 17, 18, 19, 20</div>
                `;
                document.getElementById('highNumberStats').innerHTML = `
                    <div><strong>${numberCategoryStats.high.count}</strong> dezenas (${numberCategoryStats.high.percentage.toFixed(1)}%)</div>
                    <div class="text-sm italic">21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31</div>
                `;
                
                // Exibir seção de estatísticas
                document.getElementById('numberCategoryStats').style.display = 'block';
            }
            
            // Função para renderizar as estatísticas de frequência de cada número
            function renderNumberFrequencyGrid() {
                const grid = document.getElementById('numberFrequencyGrid');
                
                if (!grid) return;
                
                grid.innerHTML = '';
                
                // Encontrar valor máximo para destacar os mais frequentes
                const maxFreq = Math.max(...Object.values(numberFrequency));
                
                // Criar elemento para cada número
                for (let i = 1; i <= 31; i++) {
                    const freq = numberFrequency[i] || 0;
                    
                    // Categorizar por faixa (baixa, média, alta)
                    let categoryClass = '';
                    if (i <= 10) {
                        categoryClass = 'freq-low'; // Números baixos (1-10)
                    } else if (i <= 20) {
                        categoryClass = 'freq-medium'; // Números médios (11-20)
                    } else {
                        categoryClass = 'freq-high'; // Números altos (21-31)
                    }
                    
                    const ball = document.createElement('div');
                    // Adiciona a classe freq-max ao número mais frequente
                    if (freq === maxFreq && freq > 0) {
                        ball.className = `frequency-ball ${categoryClass} freq-max`;
                    } else {
                        ball.className = `frequency-ball ${categoryClass}`;
                    }
                    
                    // Mostrar número
                    ball.innerHTML = formatNumber(i);
                    
                    // Adicionar contador de frequência se > 0
                    if (freq > 0) {
                        const freqValue = document.createElement('div');
                        freqValue.className = 'freq-value';
                        freqValue.textContent = freq;
                        ball.appendChild(freqValue);
                    }
                    
                    grid.appendChild(ball);
                }
            }
            
            // Função para renderizar as estatísticas de frequência dos meses
            function renderMonthFrequency() {
                const totalResults = Object.values(monthFrequency).reduce((sum, freq) => sum + freq, 0);
                
                if (totalResults === 0) return; // Não temos dados de mês
                
                // Encontrar os meses mais frequentes
                const maxFreq = Math.max(...Object.values(monthFrequency));
                
                // Atualizar cada elemento de mês
                for (const [abbrev, fullName] of Object.entries(monthNameMap)) {
                    const freq = monthFrequency[abbrev] || 0;
                    const percentage = totalResults > 0 ? (freq / totalResults * 100).toFixed(1) : '0.0';
                    
                    // ID do elemento do mês (Jan -> monthJan)
                    const monthEl = document.getElementById(`month${abbrev}`);
                    if (monthEl) {
                        // Atualizar o valor e porcentagem
                        const valueEl = monthEl.querySelector('.text-2xl');
                        const percentEl = monthEl.querySelector('.text-sm');
                        
                        if (valueEl) valueEl.textContent = freq;
                        if (percentEl) percentEl.textContent = `${percentage}%`;
                        
                        // Destacar o mês mais frequente
                        if (freq === maxFreq && freq > 0) {
                            monthEl.classList.add('month-highlight');
                        } else {
                            monthEl.classList.remove('month-highlight');
                        }
                    }
                }
            }
            
            // Função para renderizar as estatísticas de padrões de dígitos iniciais
            function renderStartDigitStats() {
                const topContainer = document.getElementById('topStartDigitPatterns');
                const moreContainer = document.getElementById('moreStartDigitPatterns');
                
                if (!topContainer || !moreContainer) return;
                
                topContainer.innerHTML = '';
                moreContainer.innerHTML = '';
                
                // Obter o total de ocorrências para calcular percentuais
                const totalOccurrences = Object.values(startDigitFrequency).reduce((sum, item) => sum + item.count, 0);
                if (totalOccurrences === 0) return;
                
                // Ordenar por frequência (do maior para o menor)
                const sortedPatterns = Object.entries(startDigitFrequency)
                    .sort((a, b) => b[1].count - a[1].count);
                
                // Renderizar apenas os 10 primeiros no container principal
                sortedPatterns.slice(0, 10).forEach(([pattern, data]) => {
                    const percentage = (data.count / totalOccurrences * 100).toFixed(1);
                    const width = Math.max(5, Math.round(data.count / sortedPatterns[0][1].count * 100));
                    
                    const patternDiv = document.createElement('div');
                    patternDiv.className = 'bg-teal-700 rounded p-2';
                    patternDiv.innerHTML = `
                        <div class="flex justify-between mb-1">
                            <div class="text-white font-medium">${pattern}</div>
                            <div class="text-teal-200">${data.count} (${percentage}%)</div>
                        </div>
                        <div class="w-full bg-teal-900 rounded-full h-2">
                            <div class="pattern-bar" style="width: ${width}%"></div>
                        </div>
                    `;
                    topContainer.appendChild(patternDiv);
                });
                
                // Renderizar o restante no container oculto
                if (sortedPatterns.length > 10) {
                    sortedPatterns.slice(10).forEach(([pattern, data]) => {
                        const percentage = (data.count / totalOccurrences * 100).toFixed(1);
                        const width = Math.max(5, Math.round(data.count / sortedPatterns[0][1].count * 100));
                        
                        const patternDiv = document.createElement('div');
                        patternDiv.className = 'bg-teal-700 rounded p-2 mt-2';
                        patternDiv.innerHTML = `
                            <div class="flex justify-between mb-1">
                                <div class="text-white font-medium">${pattern}</div>
                                <div class="text-teal-200">${data.count} (${percentage}%)</div>
                            </div>
                            <div class="w-full bg-teal-900 rounded-full h-2">
                                <div class="pattern-bar" style="width: ${width}%"></div>
                            </div>
                        `;
                        moreContainer.appendChild(patternDiv);
                    });
                    
                    // Mostrar o botão para ver mais
                    document.getElementById('showMoreStartBtn').style.display = 'block';
                } else {
                    // Ocultar o botão se não há mais itens
                    document.getElementById('showMoreStartBtn').style.display = 'none';
                }
            }
            
            // Função para renderizar as estatísticas de padrões de dígitos finais
            function renderEndDigitStats() {
                const topContainer = document.getElementById('topEndDigitPatterns');
                const moreContainer = document.getElementById('moreEndDigitPatterns');
                
                if (!topContainer || !moreContainer) return;
                
                topContainer.innerHTML = '';
                moreContainer.innerHTML = '';
                
                // Obter o total de ocorrências para calcular percentuais
                const totalOccurrences = Object.values(endDigitFrequency).reduce((sum, item) => sum + item.count, 0);
                if (totalOccurrences === 0) return;
                
                // Ordenar por frequência (do maior para o menor)
                const sortedPatterns = Object.entries(endDigitFrequency)
                    .sort((a, b) => b[1].count - a[1].count);
                
                // Renderizar apenas os 10 primeiros no container principal
                sortedPatterns.slice(0, 10).forEach(([pattern, data]) => {
                    const percentage = (data.count / totalOccurrences * 100).toFixed(1);
                    const width = Math.max(5, Math.round(data.count / sortedPatterns[0][1].count * 100));
                    
                    const patternDiv = document.createElement('div');
                    patternDiv.className = 'bg-teal-700 rounded p-2';
                    patternDiv.innerHTML = `
                        <div class="flex justify-between mb-1">
                            <div class="text-white font-medium">${pattern}</div>
                            <div class="text-teal-200">${data.count} (${percentage}%)</div>
                        </div>
                        <div class="w-full bg-teal-900 rounded-full h-2">
                            <div class="pattern-bar" style="width: ${width}%"></div>
                        </div>
                    `;
                    topContainer.appendChild(patternDiv);
                });
                
                // Renderizar o restante no container oculto
                if (sortedPatterns.length > 10) {
                    sortedPatterns.slice(10).forEach(([pattern, data]) => {
                        const percentage = (data.count / totalOccurrences * 100).toFixed(1);
                        const width = Math.max(5, Math.round(data.count / sortedPatterns[0][1].count * 100));
                        
                        const patternDiv = document.createElement('div');
                        patternDiv.className = 'bg-teal-700 rounded p-2 mt-2';
                        patternDiv.innerHTML = `
                            <div class="flex justify-between mb-1">
                                <div class="text-white font-medium">${pattern}</div>
                                <div class="text-teal-200">${data.count} (${percentage}%)</div>
                            </div>
                            <div class="w-full bg-teal-900 rounded-full h-2">
                                <div class="pattern-bar" style="width: ${width}%"></div>
                            </div>
                        `;
                        moreContainer.appendChild(patternDiv);
                    });
                    
                    // Mostrar o botão para ver mais
                    document.getElementById('showMoreEndBtn').style.display = 'block';
                } else {
                    // Ocultar o botão se não há mais itens
                    document.getElementById('showMoreEndBtn').style.display = 'none';
                }
            }
            
            // Adicionar event listeners para os botões de mostrar mais
            document.getElementById('showMoreStartBtn').addEventListener('click', function() {
                const container = document.getElementById('moreStartDigitPatterns');
                container.classList.toggle('visible');
                this.textContent = container.classList.contains('visible') ? 'Mostrar Menos' : 'Mostrar Mais';
                
                // Atualizar a altura do container pai
                frequencySection.updateHeight();
            });
            
            document.getElementById('showMoreEndBtn').addEventListener('click', function() {
                const container = document.getElementById('moreEndDigitPatterns');
                container.classList.toggle('visible');
                this.textContent = container.classList.contains('visible') ? 'Mostrar Menos' : 'Mostrar Mais';
                
                // Atualizar a altura do container pai
                frequencySection.updateHeight();
            });
            
            // Função para renderizar exemplos de padrões frequentes
            function renderPatternExamples() {
                const container = document.getElementById('patternExamples');
                if (!container) return;
                
                container.innerHTML = '';
                
                // Pegar os 5 padrões mais frequentes
                const topPatterns = patternFrequency
                    .sort((a, b) => b.frequency - a.frequency)
                    .slice(0, 5);
                
                topPatterns.forEach(pattern => {
                    const row = document.createElement('tr');
                    row.className = 'pattern-example';
                    
                    row.innerHTML = `
                        <td class="px-3 py-2 border-t border-teal-700">${pattern.example.join(' ')}</td>
                        <td class="px-3 py-2 border-t border-teal-700">${pattern.startDigitPattern}</td>
                        <td class="px-3 py-2 border-t border-teal-700">${pattern.endDigitPattern}</td>
                        <td class="px-3 py-2 border-t border-teal-700 font-semibold">${pattern.frequency}</td>
                    `;
                    
                    container.appendChild(row);
                });
                
                // Se não houver padrões, mostrar mensagem
                if (topPatterns.length === 0) {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td colspan="4" class="px-3 py-2 text-center border-t border-teal-700">
                            Nenhum padrão frequente encontrado. Faça a análise de frequência primeiro.
                        </td>
                    `;
                    container.appendChild(row);
                }
            }

            // Function to extract digits from a number
            function getDigits(num) {
                return num.toString().padStart(2, '0').split('').map(Number);
            }

            // Function to parse a month name or abbreviation 
            function parseMonth(monthStr) {
                if (!monthStr) return null;
                
                // Normalize the month string (trim, uppercase first letter)
                const normalizedMonth = monthStr.trim();
                
                // Try to match directly with our abbreviations
                for (const abbrev of Object.keys(monthNameMap)) {
                    // Match exact abbreviation
                    if (normalizedMonth.toLowerCase() === abbrev.toLowerCase()) {
                        return abbrev;
                    }
                    
                    // Match beginning of month name
                    const fullName = monthNameMap[abbrev];
                    if (normalizedMonth.toLowerCase() === fullName.toLowerCase() ||
                        normalizedMonth.toLowerCase().startsWith(fullName.toLowerCase().substring(0, 3)) || 
                        fullName.toLowerCase().startsWith(normalizedMonth.toLowerCase())) {
                        return abbrev;
                    }
                }
                
                // No match found
                return null;
            }
            
            // Função para analisar os padrões de dígitos iniciais e finais
            function analyzeDigitPatterns(results) {
                // Resetar os contadores
                startDigitFrequency = {};
                endDigitFrequency = {};
                patternFrequency = [];
                
                // Analisar cada resultado
                results.forEach(result => {
                    if (!result.numbers || result.numbers.length < 7) return; // Verificar se tem números suficientes
                    
                    // Contar os dígitos iniciais (primeiro dígito)
                    const startDigits = {};
                    // Contar os dígitos finais (último dígito)
                    const endDigits = {};
                    
                    // Para cada número no resultado
                    result.numbers.forEach(num => {
                        const numStr = num.toString().padStart(2, '0');
                        const startDigit = numStr[0];
                        const endDigit = numStr[1];
                        
                        // Incrementar a contagem do dígito inicial
                        startDigits[startDigit] = (startDigits[startDigit] || 0) + 1;
                        // Incrementar a contagem do dígito final
                        endDigits[endDigit] = (endDigits[endDigit] || 0) + 1;
                    });
                    
                    // Criar os padrões de texto
                    let startPattern = Object.entries(startDigits)
                        .sort((a, b) => b[1] - a[1]) // Ordenar por frequência
                        .map(([digit, count]) => `${count}n ${digit}`)
                        .join(' ');
                    
                    let endPattern = Object.entries(endDigits)
                        .sort((a, b) => b[1] - a[1]) // Ordenar por frequência
                        .map(([digit, count]) => `${count}n ${digit}`)
                        .join(' ');
                    
                    // Incrementar a contagem para este padrão de dígitos iniciais
                    if (!startDigitFrequency[startPattern]) {
                        startDigitFrequency[startPattern] = { count: 0, examples: [] };
                    }
                    startDigitFrequency[startPattern].count++;
                    
                    // Guardar um exemplo deste padrão
                    if (startDigitFrequency[startPattern].examples.length < 3) {
                        startDigitFrequency[startPattern].examples.push(result.numbers);
                    }
                    
                    // Incrementar a contagem para este padrão de dígitos finais
                    if (!endDigitFrequency[endPattern]) {
                        endDigitFrequency[endPattern] = { count: 0, examples: [] };
                    }
                    endDigitFrequency[endPattern].count++;
                    
                    // Guardar um exemplo deste padrão
                    if (endDigitFrequency[endPattern].examples.length < 3) {
                        endDigitFrequency[endPattern].examples.push(result.numbers);
                    }
                    
                    // Verificar se este padrão completo (início + fim) já foi registrado
                    let patternExists = false;
                    for (let i = 0; i < patternFrequency.length; i++) {
                        if (patternFrequency[i].startDigitPattern === startPattern && 
                            patternFrequency[i].endDigitPattern === endPattern) {
                            patternFrequency[i].frequency++;
                            patternExists = true;
                            break;
                        }analyzeFrequency
                    }
                    
                    // Se é um novo padrão, adicionar à lista
                    if (!patternExists) {
                        patternFrequency.push({
                            startDigitPattern: startPattern,
                            endDigitPattern: endPattern,
                            frequency: 1,
                            example: [...result.numbers]
                        });
                    }
                });
                
                // Renderizar as estatísticas
                renderStartDigitStats();
                renderEndDigitStats();
                renderPatternExamples();
                
                // Criar checkboxes para seleção de padrões
                createPatternSelectors();
                
                // Exibir a seção
                document.getElementById('digitPatternsStats').style.display = 'block';
            }


                /**
                 * Padroniza um número para o formato de dois dígitos
                 * @param {number|string} num - O número a ser formatado
                 * @returns {string} - O número formatado como string com dois dígitos
                 */
                 function formatNumber(num) {
                    // Converter para número caso seja string
                    const numInt = parseInt(num);
                    
                    // Verificar se é um número válido
                    if (isNaN(numInt)) {
                        return "";
                    }
                    
                    // Aplicar o formato com zero à esquerda se necessário
                    return numInt < 10 ? '0' + numInt : numInt.toString();
                }

                /**
                 * Processa uma array de strings para extrair números válidos
                 * @param {string[]} parts - Array de strings a serem processadas como números
                 * @returns {number[]} - Array de números válidos
                 */
                function processNumberParts(parts) {
                    return parts.map(part => {
                        // Remover qualquer caractere não numérico
                        const cleanPart = part.trim().replace(/[^\d]/g, '');
                        
                        // Converter para número
                        const num = parseInt(cleanPart);
                        
                        // Retornar o número ou NaN se inválido
                        return isNaN(num) ? NaN : num;
                    }).filter(num => !isNaN(num) && num >= 1 && num <= 31); // Filtrar para manter apenas números válidos entre 1 e 31
                }
function analyzeFrequency() {
    const resultsText = document.getElementById('historicalResults').value.trim();
    if (!resultsText) {
        alert('Por favor, insira os resultados históricos.');
        return;
    }

    const results = [];
    const lines = resultsText.split('\n');
    
    // Reset statistics
    numberCategoryStats = {
        low: { count: 0, percentage: 0 },
        medium: { count: 0, percentage: 0 },
        high: { count: 0, percentage: 0 },
        total: 0
    };
    
    // Reset number frequency
    for (let i = 1; i <= 31; i++) {
        numberFrequency[i] = 0;
    }
    
    // Reset month frequency
    for (const month in monthFrequency) {
        monthFrequency[month] = 0;
    }
    
    // Reset pattern frequency
    startDigitFrequency = {};
    endDigitFrequency = {};
    patternFrequency = [];

    // Parse each line of results
    for (const line of lines) {
        if (line.trim() === '') continue;
        
        // Split the line into words
        const parts = line.trim().split(/\s+/);
        
        // Check if the last part might be a month
        let numbers = [];
        let month = null;
        
        // If we have at least 7 numbers
        if (parts.length >= 7) {
            // Try to parse the last item as a month
            if (parts.length > 7) {
                const lastPart = parts[parts.length - 1];
                month = parseMonth(lastPart);
                
                if (month) {
                    // Se for um mês, excluir da lista de números e processar os números
                    const numberParts = parts.slice(0, -1);
                    numbers = processNumberParts(numberParts);
                } else {
                    // Se não for um mês, processar todos como números
                    numbers = processNumberParts(parts);
                }
            } else {
                // Exatamente 7 partes, assumir que todos são números
                numbers = processNumberParts(parts);
            }
            
            // Incrementar a frequência do mês, se um mês foi encontrado
            if (month) {
                monthFrequency[month]++;
            }
            
            // Só processar resultados com pelo menos 7 números válidos
            if (numbers.length >= 7) {
                // Garantir apenas os primeiros 7 números
                const validNumbers = numbers.slice(0, 7);
                
                results.push({
                    numbers: validNumbers,
                    month: month
                });
                
                // Contar números por categoria para estatísticas
                validNumbers.forEach(num => {
                    if (num >= 1 && num <= 31) { // Garantir apenas números válidos
                        numberCategoryStats.total++;
                        
                        // Incrementar a frequência para este número específico
                        numberFrequency[num] = (numberFrequency[num] || 0) + 1;
                        
                        if (num <= 10) {
                            numberCategoryStats.low.count++;
                        } else if (num <= 20) {
                            numberCategoryStats.medium.count++;
                        } else {
                            numberCategoryStats.high.count++;
                        }
                    }
                });
            }
        }
    }
    if (results.length === 0) {
        alert('Nenhum resultado válido encontrado. Verifique o formato.');
        return;
    }
    
    // Analisar padrões de dígitos
    analyzeDigitPatterns(results);
    
    // Renderiza o gráfico de estatísticas de categorias
    renderNumberCategoryChart();
    
    // Renderiza a grade de frequência dos números
    renderNumberFrequencyGrid();
    
    // Renderiza a frequência dos meses
    renderMonthFrequency();

    // Count digit occurrences in each result
    const digitCombinationCounts = {};
    
    // Inicializar contadores para todas as combinações possíveis
    validDigitCombinations.forEach(combo => {
        digitCombinationCounts[combo] = 0;
    });
    
    // Iterate through each result
    results.forEach(result => {
        // Get all digits from all numbers in this result
        const allDigits = new Set();
        result.numbers.forEach(num => {
            getDigits(num).forEach(digit => allDigits.add(digit));
        });
        
        // Convert to array and sort
        const digitsArray = Array.from(allDigits).sort((a, b) => a - b);
        
        // Only consider results with 5 or more distinct digits
        if (digitsArray.length >= 5) {
            // Verificar quais das combinações válidas estão presentes neste resultado
            validDigitCombinations.forEach(combo => {
                const comboDigits = combo.split(',').map(Number);
                
                // Verificar se todos os dígitos da combinação estão presentes
                if (comboDigits.every(digit => digitsArray.includes(digit))) {
                    digitCombinationCounts[combo]++;
                }
            });
        }
    });

    // Guardar as frequências para uso posterior
    drawnCombinations = {...digitCombinationCounts};
    
    // Convert to array for sorting
    const combinationsArray = Object.entries(digitCombinationCounts)
        .map(([combo, count]) => ({ combo, count }))
        .sort((a, b) => b.count - a.count);

    // Identificar combinações que ainda não foram sorteadas
    undrawnCombinations = validDigitCombinations.filter(combo => 
        digitCombinationCounts[combo] === 0
    );
    
    // Atualizar contador de combinações não sorteadas
    document.getElementById('undrawnCountDisplay').textContent = undrawnCombinations.length;
    
    // Display results
    const frequencyResults = document.getElementById('frequencyResults');
    const frequencyTableBody = document.getElementById('frequencyTableBody');
    const topCombinations = document.getElementById('topCombinations');
    const undrawnCombinationsContent = document.getElementById('undrawnCombinationsContent');

    // Garantir que as seções estejam visíveis
    document.getElementById('numberCategoryStats').style.display = 'block';
    document.getElementById('numberFrequencyStats').style.display = 'block';
    document.getElementById('monthFrequencyStats').style.display = 'block';
    document.getElementById('digitPatternsStats').style.display = 'block';

    frequencyResults.classList.remove('hidden');
    frequencyTableBody.innerHTML = '';
    undrawnCombinationsContent.innerHTML = '';
    
    if (combinationsArray.length === 0) {
        topCombinations.innerHTML = 'Nenhuma combinação de 5 dígitos encontrada nos resultados.';
        return;
    }

    // Show the top combinations with highlighting for 5 digits
    const top5Combos = combinationsArray.filter(item => item.count > 0).slice(0, 5);
    
    let topCombosHTML = `
        <div class="font-bold text-xl mb-3 flex items-center">
            Combinações de <span class="mx-1 bg-green-200 dark:bg-green-700 text-green-800 dark:text-green-200 px-2 py-0.5 rounded-full">5</span> Dígitos Mais Frequentes
        </div>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
    `;
    
    top5Combos.forEach((item, index) => {
        const percentage = ((item.count / results.length) * 100).toFixed(1);
        topCombosHTML += `
            <div class="bg-green-100 dark:bg-green-900 p-3 rounded-lg border-2 border-green-500">
                <div class="font-bold text-lg text-green-800 dark:text-green-200">${index + 1}. ${item.combo}</div>
                <div class="text-green-700 dark:text-green-300">
                    ${item.count} de ${results.length} resultados (${percentage}%)
                </div>
            </div>
        `;
    });
    
    topCombosHTML += `</div>`;
    
    // Adicionar informação sobre combinações que ainda não apareceram
    topCombosHTML += `
        <div class="mt-4 p-3 bg-yellow-100 dark:bg-yellow-900 rounded-lg">
            <div class="font-bold text-yellow-800 dark:text-yellow-200">
                ${undrawnCombinations.length} combinações ainda não apareceram em nenhum sorteio (de um total de ${validDigitCombinations.length})
            </div>
        </div>
    `;
    
    topCombinations.innerHTML = topCombosHTML;
    
    // Mostrar as combinações não sorteadas
    if (undrawnCombinations.length > 0) {
        undrawnCombinations.forEach(combo => {
            const comboDiv = document.createElement('div');
            comboDiv.className = 'bg-blue-50 dark:bg-blue-800 p-2 rounded border border-blue-200 dark:border-blue-700';
            comboDiv.innerHTML = `<div class="text-blue-800 dark:text-blue-200 font-medium">${combo}</div>`;
            undrawnCombinationsContent.appendChild(comboDiv);
        });
        
        document.getElementById('undrawnCombinations').style.display = 'block';
        
        // NOVA FUNCIONALIDADE: Preencher a área "Combinações de Dígitos" com apenas as não sorteadas
        document.getElementById('digitCombinations').value = undrawnCombinations.join('\n');
        
        // Atualizar a variável global para usar apenas as combinações não sorteadas
        validDigitCombinations = [...undrawnCombinations];
        
        // Atualizar o texto do cabeçalho
        const combinationsHeader = document.querySelector('#digitCombinationsHeader h2');
        if (combinationsHeader) {
            combinationsHeader.innerHTML = `
                <span>Combinações de Dígitos</span> 
                <span class="text-sm font-bold ml-2 bg-blue-100 dark:bg-blue-800 text-blue-800 dark:text-blue-200 px-2 py-0.5 rounded-full">(${undrawnCombinations.length})</span>
            `;
        }
        
        // Limpar quaisquer palpites gerados anteriormente
        document.getElementById('bettingResults').innerHTML = '';
        document.getElementById('totalBetsCount').textContent = '0';
        document.getElementById('lowCount').textContent = '0';
        document.getElementById('mediumCount').textContent = '0';
        document.getElementById('highCount').textContent = '0';
        
        // Expandir a seção de combinações de dígitos
        if (document.getElementById('digitCombinationsContainer').style.maxHeight === '0px') {
            document.getElementById('digitCombinationsHeader').click();
        }
    } else {
        document.getElementById('undrawnCombinations').style.display = 'none';
    }

    // Fill the frequency table with all combinations that appeared
    combinationsArray.filter(item => item.count > 0).forEach(({ combo, count }) => {
        const percentage = ((count / results.length) * 100).toFixed(1);
        
        const row = document.createElement('tr');
        
        // Destacar as combinações de 5 dígitos
        row.classList.add('bg-green-100', 'dark:bg-green-800');
        row.innerHTML = `
            <td class="px-2 py-2 font-bold">${combo}</td>
            <td class="px-2 py-2 font-bold">${count} de ${results.length}</td>
            <td class="px-2 py-2 font-bold">${percentage}%</td>
        `;
        
        frequencyTableBody.appendChild(row);
    });
    
    // Atualizar altura da seção de frequência após preenchimento
    frequencySection.updateHeight();
    
    // Atualizar o dropdown para mostrar as frequências nas combinações
    updateSpecificComboDropdown();
    
    // Disparar evento change para atualizar a exibição
    specificComboSelect.dispatchEvent(new Event('change'));
    
    // Verificar e expandir a seção de frequência se estiver fechada
    if (document.getElementById('frequencyContainer').style.maxHeight === '0px') {
        document.getElementById('frequencyHeader').click();
    }
    
    // Verificar se as seções importantes estão visíveis
    console.log("Status de exibição das seções após análise:");
    console.log("Frequência de Dígitos:", document.getElementById('topCombinations').style.display);
    console.log("Estatística de Dezenas:", document.getElementById('numberCategoryStats').style.display);
    console.log("Frequência de Cada Dezena:", document.getElementById('numberFrequencyStats').style.display);
    console.log("Frequência do Mês da Sorte:", document.getElementById('monthFrequencyStats').style.display);
    console.log("Padrões de Dígitos:", document.getElementById('digitPatternsStats').style.display);
    console.log("Combinações Não Sorteadas:", document.getElementById('undrawnCombinations').style.display);
}





            // Função para analisar a frequência com resultados fornecidos diretamente
            function analyzeFrequencyWithData(resultsData) {
                // Coloca os dados no campo
                document.getElementById('historicalResults').value = resultsData;
                
                // Executa a análise após garantir que os dados foram inseridos
                setTimeout(() => {
                    analyzeFrequency();
                    // Forçar atualização da interface
                    frequencySection.updateHeight();
                }, 200); // Pequeno atraso para garantir que o DOM foi atualizado
            }

            // ======== FUNÇÕES DE ACESSO À API ========
            
            // Função genérica para tentar acessar uma URL via múltiplos proxies CORS
            async function fetchViaProxy(baseUrl, customHeaders = {}) {
                // Tenta cada proxy disponível
                for (const proxyUrl of API_CONFIG.CORS_PROXY_URLS) {
                    try {
                        // Constrói a URL com o proxy
                        const url = proxyUrl.includes('?url=') ? 
                            `${proxyUrl}${encodeURIComponent(baseUrl)}` : 
                            `${proxyUrl}${baseUrl}`;
                        
                        console.log(`Tentando via proxy: ${url}`);
                        
                        const response = await fetch(url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                ...customHeaders
                            },
                            mode: 'cors'
                        });
                        
                        if (response.ok) {
                            return await response.json();
                        }
                    } catch (proxyError) {
                        console.log(`Proxy falhou (${proxyUrl}):`, proxyError);
                        // Continua para o próximo proxy
                    }
                }
                
                throw new Error('Nenhum proxy CORS conseguiu acessar a URL');
            }

			// ===== API CAIXA =====
			// Função principal para API Caixa
			async function fetchFromCaixaAPI(forceUpdate = false) {
				try {
					const cacheKey = 'caixa_dia_de_sorte_all_results';
					
					// Verificar cache primeiro, a menos que seja forçada uma atualização
					if (!forceUpdate) {
						const cachedData = LOCAL_CACHE.getCached(cacheKey);
						
						if (cachedData) {
							console.log('Usando dados em cache para todos os concursos');
							// Retornar todos os resultados do cache
							return {
								success: true,
								message: `Sucesso! Dados obtidos do cache local (${cachedData.length} concursos).`,
								formattedResults: cachedData.map(line => line.split(':')[1].trim()).join('\n'),
								source: 'cache'
							};
						}
					}
					
					// Se chegou aqui, precisamos buscar dados online
					return await fetchAllConcursos();
				} catch (error) {
					console.error(`Erro ao acessar API Caixa:`, error);
					return {
						success: false,
						message: `Falha na API Caixa: ${error.message}`
					};
				}
			}

			// Função auxiliar para buscar todos os concursos
			async function fetchAllConcursos(useProxy) {
				try {
					// Primeiro, obter o último concurso para saber quantos existem
					const latestResult = await fetchSpecificConcurso(null, useProxy);
					
					if (!latestResult.success) {
						throw new Error("Não foi possível obter o número do último concurso");
					}
					
					const lastConcursoNum = parseInt(latestResult.concursoNum);
					console.log(`Último concurso: ${lastConcursoNum}`);
					
					// Atualizar a interface para mostrar o progresso
					const apiStatusContent = document.getElementById('apiStatusContent');
					if (apiStatusContent) {
						apiStatusContent.innerHTML += `<br>Último concurso: ${lastConcursoNum}`;
						apiStatusContent.innerHTML += `<br>Iniciando busca de todos os concursos...`;
						apiStatusContent.innerHTML += `<div id="progressBar" class="w-full bg-gray-200 rounded-full h-2.5 mt-2 mb-2"><div class="bg-primary h-2.5 rounded-full" style="width: 0%"></div></div>`;
						apiStatusContent.innerHTML += `<div id="progressText" class="text-xs text-center">0/${lastConcursoNum} concursos</div>`;
					}
					
					// Array para armazenar todos os resultados
					const allResults = [];
					
					// Guardar o último resultado que já obtivemos
					allResults.push(`Concurso ${lastConcursoNum}: ${latestResult.formattedResults}`);
					
					// Configurar um atraso entre requisições para não sobrecarregar a API
					const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
					
					// Buscar concursos em lotes, começando do mais recente e indo até o primeiro
					// Vamos buscar em ordem decrescente para ter os mais recentes primeiro
					for (let i = lastConcursoNum - 1; i >= 1; i--) {
						// Atualizar a barra de progresso a cada 5 concursos
						if (i % 5 === 0 || i === 1) {
							const progressBar = document.getElementById('progressBar')?.querySelector('div');
							const progressText = document.getElementById('progressText');
							if (progressBar) {
								const progress = ((lastConcursoNum - i) / lastConcursoNum) * 100;
								progressBar.style.width = `${progress}%`;
							}
							if (progressText) {
								progressText.textContent = `${lastConcursoNum - i}/${lastConcursoNum} concursos`;
							}
						}
						
						try {
							// Buscar este concurso
							const result = await fetchSpecificConcurso(i, useProxy);
							
							// Adicionar ao array de resultados se for bem-sucedido
							if (result.success) {
								allResults.push(`Concurso ${i}: ${result.formattedResults}`);
								console.log(`Concurso ${i} obtido com sucesso`);
							} else {
								console.warn(`Falha ao obter concurso ${i}: ${result.message}`);
							}
							
							// Aguardar um breve intervalo para não sobrecarregar a API
							await delay(300); // 300ms entre requisições
						} catch (concursoError) {
							console.error(`Erro ao buscar concurso ${i}:`, concursoError);
						}
					}
					
					// Atualizar a barra de progresso para 100%
					const progressBar = document.getElementById('progressBar')?.querySelector('div');
					const progressText = document.getElementById('progressText');
					if (progressBar) progressBar.style.width = '100%';
					if (progressText) progressText.textContent = `${lastConcursoNum}/${lastConcursoNum} concursos`;
					
					// Ordenar resultados por número de concurso (crescente)
					allResults.sort((a, b) => {
						const numA = parseInt(a.match(/Concurso (\d+):/)[1]);
						const numB = parseInt(b.match(/Concurso (\d+):/)[1]);
						return numA - numB;
					});
					
					// Armazenar em cache
					const cacheKey = 'caixa_dia_de_sorte_all_results';
					LOCAL_CACHE.setCached(cacheKey, allResults, 60 * 24); // Cache por 24 horas
					
					// Atualizar informações do cache
					updateCacheInfo(lastConcursoNum, allResults.length);
					
					// Retornar os resultados sem os prefixos "Concurso X:"
					return {
						success: true,
						message: `Sucesso! Todos os ${allResults.length} concursos obtidos ${useProxy ? 'via proxy' : 'diretamente'}.`,
						formattedResults: allResults.map(line => line.split(':')[1].trim()).join('\n'),
						source: useProxy ? 'caixa-proxy' : 'caixa'
					};
				} catch (error) {
					console.error(`Erro ao buscar todos os concursos:`, error);
					return {
						success: false,
						message: `Falha ao buscar todos os concursos: ${error.message}`
					};
				}
			}
			// Função para buscar todos os concursos
async function fetchAllConcursos() {
    try {
        // Primeiro, obter o último concurso para saber quantos existem
        const latestData = await fetchLatestConcurso();
        
        if (!latestData) {
            throw new Error("Não foi possível obter o número do último concurso");
        }
        
        const lastConcursoNum = parseInt(latestData.numero);
        console.log(`Último concurso: ${lastConcursoNum}`);
        
        // Atualizar a interface para mostrar o progresso
        const apiStatusContent = document.getElementById('apiStatusContent');
        if (apiStatusContent) {
            apiStatusContent.innerHTML += `<br>Último concurso: ${lastConcursoNum}`;
            apiStatusContent.innerHTML += `<br>Iniciando busca de todos os concursos...`;
            apiStatusContent.innerHTML += `<div id="progressBar" class="w-full bg-gray-200 rounded-full h-2.5 mt-2 mb-2"><div class="bg-primary h-2.5 rounded-full" style="width: 0%"></div></div>`;
            apiStatusContent.innerHTML += `<div id="progressText" class="text-xs text-center">0/${lastConcursoNum} concursos</div>`;
        }
        
        // Array para armazenar todos os resultados
        const allResults = [];
        
        // Adicionar o último concurso que já obtivemos
        const formattedResult = formatConcursoData(latestData);
        allResults.push(`Concurso ${lastConcursoNum}: ${formattedResult}`);
        
        // Configurar um atraso entre requisições para não sobrecarregar a API
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
        
        // Buscar concursos em lotes, começando do mais recente e indo até o primeiro
        for (let i = lastConcursoNum - 1; i >= 1; i--) {
            // Atualizar a barra de progresso a cada 5 concursos
            if (i % 5 === 0 || i === 1) {
                const progressBar = document.getElementById('progressBar')?.querySelector('div');
                const progressText = document.getElementById('progressText');
                if (progressBar) {
                    const progress = ((lastConcursoNum - i) / lastConcursoNum) * 100;
                    progressBar.style.width = `${progress}%`;
                }
                if (progressText) {
                    progressText.textContent = `${lastConcursoNum - i}/${lastConcursoNum} concursos`;
                }
            }
            
            try {
                // Buscar este concurso
                const data = await fetchConcursoData(i);
                
                if (data) {
                    const formatResult = formatConcursoData(data);
                    allResults.push(`Concurso ${i}: ${formatResult}`);
                    console.log(`Concurso ${i} obtido com sucesso`);
                } else {
                    console.warn(`Falha ao obter concurso ${i}`);
                }
                
                // Aguardar um breve intervalo para não sobrecarregar a API
                await delay(300); // 300ms entre requisições
            } catch (concursoError) {
                console.error(`Erro ao buscar concurso ${i}:`, concursoError);
            }
        }
        
        // Atualizar a barra de progresso para 100%
        const progressBar = document.getElementById('progressBar')?.querySelector('div');
        const progressText = document.getElementById('progressText');
        if (progressBar) progressBar.style.width = '100%';
        if (progressText) progressText.textContent = `${lastConcursoNum}/${lastConcursoNum} concursos`;
        
        // Ordenar resultados por número de concurso (crescente)
        allResults.sort((a, b) => {
            const numA = parseInt(a.match(/Concurso (\d+):/)[1]);
            const numB = parseInt(b.match(/Concurso (\d+):/)[1]);
            return numA - numB;
        });
        
        // Armazenar em cache
        const cacheKey = 'caixa_dia_de_sorte_all_results';
        LOCAL_CACHE.setCached(cacheKey, allResults, 60 * 24); // Cache por 24 horas
        
        // Atualizar informações do cache
        updateCacheInfo(lastConcursoNum, allResults.length);
        
        // Retornar os resultados sem os prefixos "Concurso X:"
        return {
            success: true,
            message: `Sucesso! Todos os ${allResults.length} concursos obtidos.`,
            formattedResults: allResults.map(line => line.split(':')[1].trim()).join('\n'),
            source: 'caixa-proxy'
        };
    } catch (error) {
        console.error(`Erro ao buscar todos os concursos:`, error);
        return {
            success: false,
            message: `Falha ao buscar todos os concursos: ${error.message}`
        };
    }
}
			
			
                
		// Função principal para buscar resultados de acordo com as configurações do usuário
// Função principal para buscar resultados
async function fetchResultsFromAPIs(forceUpdateCache = false) {
    const spinner = document.getElementById('loadingSpinner');
    const fetchText = document.getElementById('fetchText');
    const apiStatus = document.getElementById('apiStatus');
    const apiStatusContent = document.getElementById('apiStatusContent');
    
    // Show loading spinner and status
    spinner.classList.remove('hidden');
    fetchText.textContent = 'Buscando...';
    apiStatus.classList.remove('hidden');
    apiStatusContent.innerHTML = 'Iniciando busca de resultados...';
    
    // Verificar informações de cache
    const cacheInfo = getLastCacheUpdateInfo();
    if (cacheInfo) {
        apiStatusContent.innerHTML += `<br>Cache disponível: ${cacheInfo.countConcursos} concursos, atualizado há ${cacheInfo.timeAgo}.`;
    }
    
    // Clear any previous results
    document.getElementById('historicalResults').value = '';
    
    try {
        apiStatusContent.innerHTML += `<br>Usando API oficial da Caixa via proxy CORS...`;
        
        // Apenas um método: API da Caixa via proxy CORS
        const result = await fetchFromCaixaAPI(forceUpdateCache);
        
        if (result && result.success) {
            apiStatusContent.innerHTML += `<br>✅ ${result.message}`;
            // Usar a nova função para analisar com os dados obtidos
            analyzeFrequencyWithData(result.formattedResults);
        } else {
            apiStatusContent.innerHTML += `<br>❌ ${result?.message || 'Falha ao obter resultados'}`;
            apiStatusContent.innerHTML += '<br>⚠️ Por favor, tente novamente mais tarde ou insira os dados manualmente.';
        }
    } catch (error) {
        apiStatusContent.innerHTML += `<br>❌ Erro: ${error.message}`;
        apiStatusContent.innerHTML += '<br>⚠️ Por favor, tente novamente ou insira os dados manualmente.';
    } finally {
        spinner.classList.add('hidden');
        fetchText.textContent = 'Buscar Resultados';
        frequencySection.updateHeight();
        
        // Atualizar informações do botão de cache
        updateCacheButton();
    }
}



// Função para atualizar as informações do botão de cache
function updateCacheButton() {
    const cacheInfo = getLastCacheUpdateInfo();
    const cacheInfoElement = document.getElementById('cacheInfo');
    
    if (cacheInfoElement) {
        if (cacheInfo) {
            cacheInfoElement.textContent = `Atualizado há ${cacheInfo.timeAgo}`;
        } else {
            cacheInfoElement.textContent = 'Nunca atualizado';
        }
    }
}


            // Add event listener for analyze button
            document.getElementById('analyzeBtn').addEventListener('click', analyzeFrequency);
            
            // Add event listener for generate from pattern button
            document.getElementById('generateFromPatternBtn').addEventListener('click', generateBetsFromPatterns);
            
            // Add event listener for generate from selected patterns button
            document.getElementById('generateFromSelectedPatternsBtn').addEventListener('click', generateBetsFromSelectedPatterns);
            
            // Add event listeners for download pattern buttons
            document.getElementById('downloadPatternSimpleBtn').addEventListener('click', downloadPatternSimpleBets);
            document.getElementById('downloadPatternDetailedBtn').addEventListener('click', downloadPatternDetailedBets);
			
			// Event listeners para os botões do misturador
			document.getElementById('generateMixedBtn').addEventListener('click', generateMixedBets);
			document.getElementById('downloadMixedSimpleBtn').addEventListener('click', downloadMixedSimpleBets);
			document.getElementById('downloadMixedDetailedBtn').addEventListener('click', downloadMixedDetailedBets);

			// Event listeners para os inputs do misturador
			const mixerInputs = [
				document.getElementById('totalMixedBets'),
				document.getElementById('configMixBets'),
				document.getElementById('generatedMixBets'),
				document.getElementById('patternMixBets'),
				document.getElementById('specificMixBets')
			];

			mixerInputs.forEach(input => {
				input.addEventListener('change', function() {
					if (this.value < 0) this.value = 0;
					adjustMixerDistribution();
				});
			});
            
            // Desabilitar botões de download de padrões inicialmente
            document.getElementById('downloadPatternSimpleBtn').disabled = true;
            document.getElementById('downloadPatternDetailedBtn').disabled = true;
            
            // Configurar event listener para botão de busca
            document.getElementById('fetchResultsBtn').addEventListener('click', fetchResultsFromAPIs);

            // Configurar a distribuição por faixa
            setupRangeDistribution();
            
            // Configurar botão para gerar resultados
            document.getElementById('generateBtn').addEventListener('click', generateResults);

            // Configurar botão para imprimir resultados
            document.getElementById('printBtn').addEventListener('click', function() {
                window.print();
            });
            
            // Configurar download de botões
            document.getElementById('downloadSimpleBtn').addEventListener('click', downloadSimpleBets);
            document.getElementById('downloadBtn').addEventListener('click', downloadBets);
            document.getElementById('downloadUndrawnBtn').addEventListener('click', downloadUndrawnCombinations);
            document.getElementById('downloadSpecificBtn').addEventListener('click', downloadSpecificBets);
            document.getElementById('downloadSpecificSimpleBtn').addEventListener('click', downloadSpecificSimpleBets);
            
            // Configurar botão para gerar palpites específicos
            document.getElementById('generateSpecificBtn').addEventListener('click', generateSpecificBets);
            
            // Configurar navegação de paginação
            document.getElementById('prevPageBtn').addEventListener('click', function() {
                if (currentPage > 1) {
                    currentPage--;
                    setupPagination();
                }
            });
            
            document.getElementById('nextPageBtn').addEventListener('click', function() {
                const totalPages = Math.ceil(specificGeneratedBets.length / itemsPerPage);
                if (currentPage < totalPages) {
                    currentPage++;
                    setupPagination();
                }
            });

            // Inicializar com os dados padrão
            specificComboSelect.addEventListener('change', updatePossibleNumbers);
            updatePossibleNumbers();
            setupTabs();
			// FUNÇÕES PARA O MISTURADOR DE PALPITES

		// Ajustar a distribuição do misturador para atingir o total desejado
		function adjustMixerDistribution() {
			const totalMixedBets = parseInt(document.getElementById('totalMixedBets').value);
			const configMixBets = parseInt(document.getElementById('configMixBets').value) || 0;
			const generatedMixBets = parseInt(document.getElementById('generatedMixBets').value) || 0;
			const patternMixBets = parseInt(document.getElementById('patternMixBets').value) || 0;
			const specificMixBets = parseInt(document.getElementById('specificMixBets').value) || 0;
			
			// Calcular o total atual
			const currentTotal = configMixBets + generatedMixBets + patternMixBets + specificMixBets;
			
			// Se o total atual for diferente do desejado, ajustar automaticamente
			if (currentTotal !== totalMixedBets && totalMixedBets > 0) {
				// Calcular a proporção de cada tipo
				const proportion = {
					config: configMixBets / Math.max(currentTotal, 1),
					generated: generatedMixBets / Math.max(currentTotal, 1),
					pattern: patternMixBets / Math.max(currentTotal, 1),
					specific: specificMixBets / Math.max(currentTotal, 1)
				};
				
				// Ajustar os valores mantendo as proporções
				document.getElementById('configMixBets').value = Math.round(proportion.config * totalMixedBets);
				document.getElementById('generatedMixBets').value = Math.round(proportion.generated * totalMixedBets);
				document.getElementById('patternMixBets').value = Math.round(proportion.pattern * totalMixedBets);
				
				// O último valor é ajustado para garantir que a soma seja exatamente igual ao total
				const firstThree = 
					Math.round(proportion.config * totalMixedBets) +
					Math.round(proportion.generated * totalMixedBets) +
					Math.round(proportion.pattern * totalMixedBets);
					
				document.getElementById('specificMixBets').value = totalMixedBets - firstThree;
			}
		}

		// Gerar palpites misturados de diferentes seções
		function generateMixedBets() {
			const totalMixedBets = parseInt(document.getElementById('totalMixedBets').value);
			
			// Obter as quantidades desejadas de cada tipo de palpite
			const configMixBets = parseInt(document.getElementById('configMixBets').value) || 0;
			const generatedMixBets = parseInt(document.getElementById('generatedMixBets').value) || 0;
			const patternMixBets = parseInt(document.getElementById('patternMixBets').value) || 0;
			const specificMixBets = parseInt(document.getElementById('specificMixBets').value) || 0;
			
			// Verificar se há palpites suficientes gerados em cada seção
			if (configMixBets > 0 && allGeneratedBets.length === 0) {
				alert('Não há palpites gerados na seção Configurações. Gere-os primeiro ou reduza a quantidade solicitada.');
				return;
			}
			
			if (patternMixBets > 0 && patternGeneratedBets.length === 0) {
				alert('Não há palpites gerados na seção Padrões de Dígitos. Gere-os primeiro ou reduza a quantidade solicitada.');
				return;
			}
			
			if (specificMixBets > 0 && specificGeneratedBets.length === 0) {
				alert('Não há palpites gerados na seção Gerador por Combinação Específica. Gere-os primeiro ou reduza a quantidade solicitada.');
				return;
			}
			
			// Limpar o array de palpites misturados
			mixedGeneratedBets = [];
			
			// Adicionar palpites de Configurações
			if (configMixBets > 0 && allGeneratedBets.length > 0) {
				// Se não houver palpites suficientes, usar os disponíveis repetidamente
				for (let i = 0; i < configMixBets; i++) {
					const index = i % allGeneratedBets.length;
					const bet = JSON.parse(JSON.stringify(allGeneratedBets[index])); // Cópia profunda
					bet.source = 'Configurações';
					mixedGeneratedBets.push(bet);
				}
			}
			
			// Adicionar palpites gerados anteriormente
			if (generatedMixBets > 0 && allGeneratedBets.length > 0) {
				// Embaralhar os palpites para obter uma seleção aleatória
				const shuffledBets = [...allGeneratedBets].sort(() => 0.5 - Math.random());
				
				for (let i = 0; i < generatedMixBets && i < shuffledBets.length; i++) {
					const bet = JSON.parse(JSON.stringify(shuffledBets[i])); // Cópia profunda
					bet.source = 'Palpites Gerados';
					
					// Evitar duplicatas
					if (!mixedGeneratedBets.some(existingBet => 
						existingBet.numbers.length === bet.numbers.length && 
						existingBet.numbers.every((num, idx) => num === bet.numbers[idx])
					)) {
						mixedGeneratedBets.push(bet);
					}
				}
			}
			
			// Adicionar palpites de padrões
			if (patternMixBets > 0 && patternGeneratedBets.length > 0) {
				for (let i = 0; i < patternMixBets; i++) {
					const index = i % patternGeneratedBets.length;
					const bet = JSON.parse(JSON.stringify(patternGeneratedBets[index])); // Cópia profunda
					bet.source = 'Padrões de Dígitos';
					
					// Evitar duplicatas
					if (!mixedGeneratedBets.some(existingBet => 
						existingBet.numbers.length === bet.numbers.length && 
						existingBet.numbers.every((num, idx) => num === bet.numbers[idx])
					)) {
						mixedGeneratedBets.push(bet);
					}
				}
			}
			
			// Adicionar palpites específicos
			if (specificMixBets > 0 && specificGeneratedBets.length > 0) {
				for (let i = 0; i < specificMixBets; i++) {
					const index = i % specificGeneratedBets.length;
					const bet = JSON.parse(JSON.stringify(specificGeneratedBets[index])); // Cópia profunda
					bet.source = 'Combinação Específica';
					
					// Evitar duplicatas
					if (!mixedGeneratedBets.some(existingBet => 
						existingBet.numbers.length === bet.numbers.length && 
						existingBet.numbers.every((num, idx) => num === bet.numbers[idx])
					)) {
						mixedGeneratedBets.push(bet);
					}
				}
			}
			
			// Limitar ao número total desejado
			mixedGeneratedBets = mixedGeneratedBets.slice(0, totalMixedBets);
			
			// Embaralhar a ordem final dos palpites
			mixedGeneratedBets.sort(() => 0.5 - Math.random());
			
			// Exibir os palpites misturados
			displayMixedBets();
		}

		// Exibir palpites misturados
		function displayMixedBets() {
			const container = document.getElementById('mixedResultsContainer');
			container.innerHTML = '';
			
			// Exibir container
			document.getElementById('mixedBetsContainer').classList.remove('hidden');
			
			// Criar card para cada palpite
			mixedGeneratedBets.forEach((bet, index) => {
				const card = document.createElement('div');
				card.className = 'p-4 bg-gray-100 dark:bg-gray-700 rounded';
				
				// Contagem de números por categoria
				const lowCount = bet.numbers.filter(n => parseInt(n) <= 10).length;
				const mediumCount = bet.numbers.filter(n => parseInt(n) > 10 && parseInt(n) <= 20).length;
				const highCount = bet.numbers.filter(n => parseInt(n) > 20).length;
				
				// Cor da fonte para a fonte de origem
				let sourceColor = 'text-gray-600';
				if (bet.source === 'Padrões de Dígitos') {
					sourceColor = 'text-indigo-600 dark:text-indigo-400';
				} else if (bet.source === 'Combinação Específica') {
					sourceColor = 'text-green-600 dark:text-green-400';
				}
				
				// Conteúdo do card
				let numbersHTML = '';
				bet.numbers.forEach(num => {
					let numberClass = '';
					if (parseInt(num) <= 10) {
						numberClass = 'number-low';
					} else if (parseInt(num) <= 20) {
						numberClass = 'number-medium';
					} else {
						numberClass = 'number-high';
					}
					
					numbersHTML += `<span class="inline-block w-8 h-8 text-center leading-8 rounded-full mr-1 mb-1 ${numberClass}">${num}</span>`;
				});
				
				card.innerHTML = `
					<div class="text-sm text-gray-600 dark:text-gray-400 mb-1">Palpite ${index + 1} <span class="${sourceColor} font-medium">(${bet.source})</span></div>
					<div class="mb-2">${numbersHTML}</div>
					<div class="text-sm text-gray-600 dark:text-gray-400">
						<div>Combinação: ${bet.combination}</div>
						<div>Distribuição: ${lowCount} B + ${mediumCount} M + ${highCount} A</div>
					</div>
				`;
				
				container.appendChild(card);
			});
			
			// Atualizar altura da seção
			mixerSection.updateHeight();
		}

		// Baixar palpites misturados (somente dezenas)
		function downloadMixedSimpleBets() {
			if (mixedGeneratedBets.length === 0) {
				alert('Nenhum palpite misturado gerado ainda. Gere-os primeiro.');
				return;
			}
			
			let content = 'Palpites Misturados - Dia de Sorte\n\n';
			
			mixedGeneratedBets.forEach((bet, index) => {
				content += `${index + 1}: ${bet.numbers.map(formatNumber).join(' ')}\n`;
			});
			
			downloadFile('palpites_misturados_dia_de_sorte.txt', content);
		}

		// Baixar palpites misturados (detalhado)
		function downloadMixedDetailedBets() {
			if (mixedGeneratedBets.length === 0) {
				alert('Nenhum palpite misturado gerado ainda. Gere-os primeiro.');
				return;
			}
			
			let content = 'Palpites Misturados - Dia de Sorte\n\n';
			content += 'Estes palpites foram gerados combinando diferentes estratégias de geração de palpites.\n\n';
			
			mixedGeneratedBets.forEach((bet, index) => {
				content += `Palpite ${index + 1}:\n`;
				content += `Dezenas: ${bet.numbers.join(' ')}\n`;
				content += `Origem: ${bet.source}\n`;
				content += `Combinação de dígitos: ${bet.combination}\n`;
				
				if (bet.startPattern && bet.endPattern) {
					content += `Padrão inicial: ${bet.startPattern}\n`;
					content += `Padrão final: ${bet.endPattern}\n`;
				}
				
				const lowCount = bet.numbers.filter(n => parseInt(n) <= 10).length;
				const mediumCount = bet.numbers.filter(n => parseInt(n) > 10 && parseInt(n) <= 20).length;
				const highCount = bet.numbers.filter(n => parseInt(n) > 20).length;
				
				content += `Distribuição: ${lowCount} baixas (1-10), ${mediumCount} médias (11-20), ${highCount} altas (21-31)\n\n`;
			});
			
			content += 'Gerado por: Gerador de Palpites - Dia de Sorte\n';
			content += 'Estratégia: Mistura de diferentes técnicas de geração de palpites\n';
			
			downloadFile('analise_palpites_misturados_dia_de_sorte.txt', content);
			}
			
			// Função auxiliar para baixar arquivos
			// Qualquer coisa excluir se não funcionar...
			function downloadFile(filename, content) {
				const element = document.createElement('a');
				element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(content));
				element.setAttribute('download', filename);
				element.style.display = 'none';
				document.body.appendChild(element);
				element.click();
				document.body.removeChild(element);
			}
        });
    </script>
    
    <footer>Feito por: <i>Márcio Fernando Maia -  Todos os direitos reservado - 2025</i></footer>
</body>
</html>